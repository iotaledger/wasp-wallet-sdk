// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types
import (
	"encoding/json"
	"fmt"
	"reflect"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *FaucetMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in FaucetMethodData: required")
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in FaucetMethodData: required")
	}
	type Plain FaucetMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FaucetMethodData(plain)
	return nil
}


// Account identifier Could be the account index (number) or account alias (string)

// Address with unspent outputs
type AddressWithUnspentOutputs struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Internal corresponds to the JSON schema field "internal".
	Internal bool `json:"internal" yaml:"internal" mapstructure:"internal"`

	// KeyIndex corresponds to the JSON schema field "keyIndex".
	KeyIndex float64 `json:"keyIndex" yaml:"keyIndex" mapstructure:"keyIndex"`

	// OutputIds corresponds to the JSON schema field "outputIds".
	OutputIds []string `json:"outputIds" yaml:"outputIds" mapstructure:"outputIds"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AddressWithUnspentOutputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in AddressWithUnspentOutputs: required")
	}
	if v, ok := raw["internal"]; !ok || v == nil {
		return fmt.Errorf("field internal in AddressWithUnspentOutputs: required")
	}
	if v, ok := raw["keyIndex"]; !ok || v == nil {
		return fmt.Errorf("field keyIndex in AddressWithUnspentOutputs: required")
	}
	if v, ok := raw["outputIds"]; !ok || v == nil {
		return fmt.Errorf("field outputIds in AddressWithUnspentOutputs: required")
	}
	type Plain AddressWithUnspentOutputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AddressWithUnspentOutputs(plain)
	return nil
}

// Input options for GenerateAddresses
type IGenerateAddressesOptions struct {
	// AccountIndex corresponds to the JSON schema field "accountIndex".
	AccountIndex float64 `json:"accountIndex,omitempty" yaml:"accountIndex,omitempty" mapstructure:"accountIndex,omitempty"`

	// Bech32 human readable part
	Bech32Hrp string `json:"bech32Hrp,omitempty" yaml:"bech32Hrp,omitempty" mapstructure:"bech32Hrp,omitempty"`

	// CoinType corresponds to the JSON schema field "coinType".
	CoinType *CoinType `json:"coinType,omitempty" yaml:"coinType,omitempty" mapstructure:"coinType,omitempty"`

	// Internal addresses
	Internal bool `json:"internal,omitempty" yaml:"internal,omitempty" mapstructure:"internal,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *IGenerateAddressOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Range corresponds to the JSON schema field "range".
	Range *IRange `json:"range,omitempty" yaml:"range,omitempty" mapstructure:"range,omitempty"`
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifySecp256K1EcdsaSignatureMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in VerifySecp256K1EcdsaSignatureMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in VerifySecp256K1EcdsaSignatureMethod: required")
	}
	type Plain VerifySecp256K1EcdsaSignatureMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifySecp256K1EcdsaSignatureMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *CoinType) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_CoinType {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CoinType, v)
	}
	*j = CoinType(v)
	return nil
}


type InclusionState string


// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifySecp256K1EcdsaSignatureMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in VerifySecp256K1EcdsaSignatureMethodData: required")
	}
	if v, ok := raw["publicKey"]; !ok || v == nil {
		return fmt.Errorf("field publicKey in VerifySecp256K1EcdsaSignatureMethodData: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in VerifySecp256K1EcdsaSignatureMethodData: required")
	}
	type Plain VerifySecp256K1EcdsaSignatureMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifySecp256K1EcdsaSignatureMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *InclusionState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_InclusionState {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InclusionState, v)
	}
	*j = InclusionState(v)
	return nil
}


const InclusionStatePending InclusionState = "Pending"
const InclusionStateConfirmed InclusionState = "Confirmed"
const InclusionStateConflicting InclusionState = "Conflicting"
const InclusionStateUnknownPruned InclusionState = "UnknownPruned"
// Hex encoded bytes.


// Details of an output.


// UnmarshalJSON implements json.Unmarshaler.
func (j *IOutputMetadataResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in IOutputMetadataResponse: required")
	}
	if v, ok := raw["isSpent"]; !ok || v == nil {
		return fmt.Errorf("field isSpent in IOutputMetadataResponse: required")
	}
	if v, ok := raw["ledgerIndex"]; !ok || v == nil {
		return fmt.Errorf("field ledgerIndex in IOutputMetadataResponse: required")
	}
	if v, ok := raw["milestoneIndexBooked"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndexBooked in IOutputMetadataResponse: required")
	}
	if v, ok := raw["milestoneTimestampBooked"]; !ok || v == nil {
		return fmt.Errorf("field milestoneTimestampBooked in IOutputMetadataResponse: required")
	}
	if v, ok := raw["outputIndex"]; !ok || v == nil {
		return fmt.Errorf("field outputIndex in IOutputMetadataResponse: required")
	}
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in IOutputMetadataResponse: required")
	}
	type Plain IOutputMetadataResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IOutputMetadataResponse(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyMnemonicMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in VerifyMnemonicMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in VerifyMnemonicMethod: required")
	}
	type Plain VerifyMnemonicMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifyMnemonicMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyMnemonicMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["mnemonic"]; !ok || v == nil {
		return fmt.Errorf("field mnemonic in VerifyMnemonicMethodData: required")
	}
	type Plain VerifyMnemonicMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifyMnemonicMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in OutputResponse: required")
	}
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in OutputResponse: required")
	}
	type Plain OutputResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = OutputResponse(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEd25519SignatureMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in VerifyEd25519SignatureMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in VerifyEd25519SignatureMethod: required")
	}
	type Plain VerifyEd25519SignatureMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifyEd25519SignatureMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEd25519SignatureMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in VerifyEd25519SignatureMethodData: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in VerifyEd25519SignatureMethodData: required")
	}
	type Plain VerifyEd25519SignatureMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifyEd25519SignatureMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEd25519SignatureMethodDataSignature) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["publicKey"]; !ok || v == nil {
		return fmt.Errorf("field publicKey in VerifyEd25519SignatureMethodDataSignature: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in VerifyEd25519SignatureMethodDataSignature: required")
	}
	type Plain VerifyEd25519SignatureMethodDataSignature
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VerifyEd25519SignatureMethodDataSignature(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["essence"]; !ok || v == nil {
		return fmt.Errorf("field essence in TransactionPayload: required")
	}
	if v, ok := raw["unlocks"]; !ok || v == nil {
		return fmt.Errorf("field unlocks in TransactionPayload: required")
	}
	type Plain TransactionPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionPayload(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transaction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["inclusionState"]; !ok || v == nil {
		return fmt.Errorf("field inclusionState in Transaction: required")
	}
	if v, ok := raw["incoming"]; !ok || v == nil {
		return fmt.Errorf("field incoming in Transaction: required")
	}
	if v, ok := raw["inputs"]; !ok || v == nil {
		return fmt.Errorf("field inputs in Transaction: required")
	}
	if v, ok := raw["networkId"]; !ok || v == nil {
		return fmt.Errorf("field networkId in Transaction: required")
	}
	if v, ok := raw["payload"]; !ok || v == nil {
		return fmt.Errorf("field payload in Transaction: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp in Transaction: required")
	}
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in Transaction: required")
	}
	type Plain Transaction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Transaction(plain)
	return nil
}


// Incoming transactions with their inputs if available and not already pruned
type AccountMetaIncomingTransactions map[string][]Transaction

// Output IDs of unspent outputs that are currently used as input for transactions
type AccountMetaLockedOutputs struct {
	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountMetaLockedOutputs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in AccountMetaLockedOutputs: required")
	}
	type Plain AccountMetaLockedOutputs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AccountMetaLockedOutputs(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateNodeAuthMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in UpdateNodeAuthMethodData: required")
	}
	type Plain UpdateNodeAuthMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = UpdateNodeAuthMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *UnspentOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in UnspentOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in UnspentOutputsMethod: required")
	}
	type Plain UnspentOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = UnspentOutputsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentBsBuffer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in SegmentBsBuffer: required")
	}
	type Plain SegmentBsBuffer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SegmentBsBuffer(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *UnhealthyNodesMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in UnhealthyNodesMethod: required")
	}
	type Plain UnhealthyNodesMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = UnhealthyNodesMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentBs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["BYTES_PER_ELEMENT"]; !ok || v == nil {
		return fmt.Errorf("field BYTES_PER_ELEMENT in SegmentBs: required")
	}
	if v, ok := raw["buffer"]; !ok || v == nil {
		return fmt.Errorf("field buffer in SegmentBs: required")
	}
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in SegmentBs: required")
	}
	if v, ok := raw["byteOffset"]; !ok || v == nil {
		return fmt.Errorf("field byteOffset in SegmentBs: required")
	}
	if v, ok := raw["length"]; !ok || v == nil {
		return fmt.Errorf("field length in SegmentBs: required")
	}
	type Plain SegmentBs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SegmentBs(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in TransactionsMethod: required")
	}
	type Plain TransactionsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *Segment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["bs"]; !ok || v == nil {
		return fmt.Errorf("field bs in Segment: required")
	}
	if v, ok := raw["hardened"]; !ok || v == nil {
		return fmt.Errorf("field hardened in Segment: required")
	}
	type Plain Segment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Segment(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in TransactionIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in TransactionIdMethod: required")
	}
	type Plain TransactionIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionIdMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["payload"]; !ok || v == nil {
		return fmt.Errorf("field payload in TransactionIdMethodData: required")
	}
	type Plain TransactionIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionIdMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionIdMethodDataPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["essence"]; !ok || v == nil {
		return fmt.Errorf("field essence in TransactionIdMethodDataPayload: required")
	}
	if v, ok := raw["unlocks"]; !ok || v == nil {
		return fmt.Errorf("field unlocks in TransactionIdMethodDataPayload: required")
	}
	type Plain TransactionIdMethodDataPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionIdMethodDataPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in OutputData: required")
	}
	if v, ok := raw["isSpent"]; !ok || v == nil {
		return fmt.Errorf("field isSpent in OutputData: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in OutputData: required")
	}
	if v, ok := raw["networkId"]; !ok || v == nil {
		return fmt.Errorf("field networkId in OutputData: required")
	}
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in OutputData: required")
	}
	if v, ok := raw["outputId"]; !ok || v == nil {
		return fmt.Errorf("field outputId in OutputData: required")
	}
	if v, ok := raw["remainder"]; !ok || v == nil {
		return fmt.Errorf("field remainder in OutputData: required")
	}
	type Plain OutputData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = OutputData(plain)
	return nil
}


type AccountMetaOutputs map[string]OutputData

// Transaction IDs of pending transactions
type AccountMetaPendingTransactions struct {
	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountMetaPendingTransactions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in AccountMetaPendingTransactions: required")
	}
	type Plain AccountMetaPendingTransactions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AccountMetaPendingTransactions(plain)
	return nil
}


type AccountMetaTransactions map[string]Transaction

type AccountMetaUnspentOutputs map[string]OutputData

// The account object
type AccountMeta struct {
	// AddressesWithUnspentOutputs corresponds to the JSON schema field
	// "addressesWithUnspentOutputs".
	AddressesWithUnspentOutputs []AddressWithUnspentOutputs `json:"addressesWithUnspentOutputs" yaml:"addressesWithUnspentOutputs" mapstructure:"addressesWithUnspentOutputs"`

	// Alias corresponds to the JSON schema field "alias".
	Alias string `json:"alias" yaml:"alias" mapstructure:"alias"`

	// CoinType corresponds to the JSON schema field "coinType".
	CoinType CoinType `json:"coinType" yaml:"coinType" mapstructure:"coinType"`

	// Incoming transactions with their inputs if available and not already pruned
	IncomingTransactions AccountMetaIncomingTransactions `json:"incomingTransactions" yaml:"incomingTransactions" mapstructure:"incomingTransactions"`

	// Index corresponds to the JSON schema field "index".
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`

	// InternalAddresses corresponds to the JSON schema field "internalAddresses".
	InternalAddresses []AccountAddress `json:"internalAddresses" yaml:"internalAddresses" mapstructure:"internalAddresses"`

	// Output IDs of unspent outputs that are currently used as input for transactions
	LockedOutputs AccountMetaLockedOutputs `json:"lockedOutputs" yaml:"lockedOutputs" mapstructure:"lockedOutputs"`

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs AccountMetaOutputs `json:"outputs" yaml:"outputs" mapstructure:"outputs"`

	// Transaction IDs of pending transactions
	PendingTransactions AccountMetaPendingTransactions `json:"pendingTransactions" yaml:"pendingTransactions" mapstructure:"pendingTransactions"`

	// PublicAddresses corresponds to the JSON schema field "publicAddresses".
	PublicAddresses []AccountAddress `json:"publicAddresses" yaml:"publicAddresses" mapstructure:"publicAddresses"`

	// Transactions corresponds to the JSON schema field "transactions".
	Transactions AccountMetaTransactions `json:"transactions" yaml:"transactions" mapstructure:"transactions"`

	// UnspentOutputs corresponds to the JSON schema field "unspentOutputs".
	UnspentOutputs AccountMetaUnspentOutputs `json:"unspentOutputs" yaml:"unspentOutputs" mapstructure:"unspentOutputs"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["addressesWithUnspentOutputs"]; !ok || v == nil {
		return fmt.Errorf("field addressesWithUnspentOutputs in AccountMeta: required")
	}
	if v, ok := raw["alias"]; !ok || v == nil {
		return fmt.Errorf("field alias in AccountMeta: required")
	}
	if v, ok := raw["coinType"]; !ok || v == nil {
		return fmt.Errorf("field coinType in AccountMeta: required")
	}
	if v, ok := raw["incomingTransactions"]; !ok || v == nil {
		return fmt.Errorf("field incomingTransactions in AccountMeta: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in AccountMeta: required")
	}
	if v, ok := raw["internalAddresses"]; !ok || v == nil {
		return fmt.Errorf("field internalAddresses in AccountMeta: required")
	}
	if v, ok := raw["lockedOutputs"]; !ok || v == nil {
		return fmt.Errorf("field lockedOutputs in AccountMeta: required")
	}
	if v, ok := raw["outputs"]; !ok || v == nil {
		return fmt.Errorf("field outputs in AccountMeta: required")
	}
	if v, ok := raw["pendingTransactions"]; !ok || v == nil {
		return fmt.Errorf("field pendingTransactions in AccountMeta: required")
	}
	if v, ok := raw["publicAddresses"]; !ok || v == nil {
		return fmt.Errorf("field publicAddresses in AccountMeta: required")
	}
	if v, ok := raw["transactions"]; !ok || v == nil {
		return fmt.Errorf("field transactions in AccountMeta: required")
	}
	if v, ok := raw["unspentOutputs"]; !ok || v == nil {
		return fmt.Errorf("field unspentOutputs in AccountMeta: required")
	}
	type Plain AccountMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AccountMeta(plain)
	return nil
}


// The account metadata
type AccountMetadata struct {
	// The account alias
	Alias string `json:"alias" yaml:"alias" mapstructure:"alias"`

	// The used coin type
	CoinType CoinType `json:"coinType" yaml:"coinType" mapstructure:"coinType"`

	// The account index which will be used in the BIP32 path
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["alias"]; !ok || v == nil {
		return fmt.Errorf("field alias in AccountMetadata: required")
	}
	if v, ok := raw["coinType"]; !ok || v == nil {
		return fmt.Errorf("field coinType in AccountMetadata: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in AccountMetadata: required")
	}
	type Plain AccountMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AccountMetadata(plain)
	return nil
}


// Specifies what outputs should be synced for the ed25519 addresses from the
// account.


type AliasOutputBuilderParamsFeaturesElem map[string]interface{}

type AliasOutputBuilderParamsImmutableFeaturesElem map[string]interface{}

// Hex encoded U256.
type HexEncodedAmount string

// Native token.
type INativeToken struct {
	// Amount of native tokens of the given Token ID.
	Amount HexEncodedAmount `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Identifier of the native token.
	Id HexEncodedString `json:"id" yaml:"id" mapstructure:"id"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INativeToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in INativeToken: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in INativeToken: required")
	}
	type Plain INativeToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INativeToken(plain)
	return nil
}


type AliasOutputBuilderParamsUnlockConditionsElem map[string]interface{}

// Options for building an Alias Output
type AliasOutputBuilderParams struct {
	// AliasId corresponds to the JSON schema field "aliasId".
	AliasId HexEncodedString `json:"aliasId" yaml:"aliasId" mapstructure:"aliasId"`

	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features to be contained by the output.
	Features []AliasOutputBuilderParamsFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// FoundryCounter corresponds to the JSON schema field "foundryCounter".
	FoundryCounter float64 `json:"foundryCounter,omitempty" yaml:"foundryCounter,omitempty" mapstructure:"foundryCounter,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []AliasOutputBuilderParamsImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// The native tokens to be held by the output.
	NativeTokens []INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// StateIndex corresponds to the JSON schema field "stateIndex".
	StateIndex float64 `json:"stateIndex,omitempty" yaml:"stateIndex,omitempty" mapstructure:"stateIndex,omitempty"`

	// StateMetadata corresponds to the JSON schema field "stateMetadata".
	StateMetadata *HexEncodedString `json:"stateMetadata,omitempty" yaml:"stateMetadata,omitempty" mapstructure:"stateMetadata,omitempty"`

	// The unlock conditions for the output.
	UnlockConditions []AliasOutputBuilderParamsUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasOutputBuilderParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliasId"]; !ok || v == nil {
		return fmt.Errorf("field aliasId in AliasOutputBuilderParams: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in AliasOutputBuilderParams: required")
	}
	type Plain AliasOutputBuilderParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasOutputBuilderParams(plain)
	return nil
}


// Options for the alias output creation
type AliasOutputParams struct {
	// Bech32 encoded address to which the Nft will be minted. Default will use the
	// first address of the account
	Address string `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	// Hex encoded bytes
	ImmutableMetadata string `json:"immutableMetadata,omitempty" yaml:"immutableMetadata,omitempty" mapstructure:"immutableMetadata,omitempty"`

	// Hex encoded bytes
	Metadata string `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Hex encoded bytes
	StateMetadata string `json:"stateMetadata,omitempty" yaml:"stateMetadata,omitempty" mapstructure:"stateMetadata,omitempty"`
}

// Query parameters for filtering Alias Outputs
type AliasQueryParameter interface{}

// Specifies what outputs should be synced for the address of an alias output.


type Answer struct {
	// AdditionalInfo corresponds to the JSON schema field "additionalInfo".
	AdditionalInfo string `json:"additionalInfo" yaml:"additionalInfo" mapstructure:"additionalInfo"`

	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *Answer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["additionalInfo"]; !ok || v == nil {
		return fmt.Errorf("field additionalInfo in Answer: required")
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in Answer: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in Answer: required")
	}
	type Plain Answer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Answer(plain)
	return nil
}


type AnswerStatus struct {
	// Accumulated corresponds to the JSON schema field "accumulated".
	Accumulated float64 `json:"accumulated" yaml:"accumulated" mapstructure:"accumulated"`

	// Current corresponds to the JSON schema field "current".
	Current float64 `json:"current" yaml:"current" mapstructure:"current"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AnswerStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["accumulated"]; !ok || v == nil {
		return fmt.Errorf("field accumulated in AnswerStatus: required")
	}
	if v, ok := raw["current"]; !ok || v == nil {
		return fmt.Errorf("field current in AnswerStatus: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in AnswerStatus: required")
	}
	type Plain AnswerStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AnswerStatus(plain)
	return nil
}


// Assets to include in the output
type Assets struct {
	// NativeTokens corresponds to the JSON schema field "nativeTokens".
	NativeTokens []INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId *HexEncodedString `json:"nftId,omitempty" yaml:"nftId,omitempty" mapstructure:"nftId,omitempty"`
}

// The balance of the base coin
type BaseCoinBalance struct {
	// The amount of the outputs that aren't used in a transaction
	Available string `json:"available" yaml:"available" mapstructure:"available"`

	// The total amount of the outputs
	Total string `json:"total" yaml:"total" mapstructure:"total"`

	// Voting power
	VotingPower string `json:"votingPower" yaml:"votingPower" mapstructure:"votingPower"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseCoinBalance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["available"]; !ok || v == nil {
		return fmt.Errorf("field available in BaseCoinBalance: required")
	}
	if v, ok := raw["total"]; !ok || v == nil {
		return fmt.Errorf("field total in BaseCoinBalance: required")
	}
	if v, ok := raw["votingPower"]; !ok || v == nil {
		return fmt.Errorf("field votingPower in BaseCoinBalance: required")
	}
	type Plain BaseCoinBalance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BaseCoinBalance(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SyncAccountMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SyncAccountMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SyncAccountMethod: required")
	}
	type Plain SyncAccountMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SyncAccountMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NativeTokenBalance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["available"]; !ok || v == nil {
		return fmt.Errorf("field available in NativeTokenBalance: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in NativeTokenBalance: required")
	}
	if v, ok := raw["total"]; !ok || v == nil {
		return fmt.Errorf("field total in NativeTokenBalance: required")
	}
	type Plain NativeTokenBalance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NativeTokenBalance(plain)
	return nil
}


// Outputs with multiple unlock conditions and if they can currently be spent or
// not. If there is a TimelockUnlockCondition or ExpirationUnlockCondition this can
// change at any time
type BalancePotentiallyLockedOutputs map[string]bool


// UnmarshalJSON implements json.Unmarshaler.
func (j *SubmitAndStoreTransactionMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SubmitAndStoreTransactionMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SubmitAndStoreTransactionMethod: required")
	}
	type Plain SubmitAndStoreTransactionMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SubmitAndStoreTransactionMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RequiredStorageDeposit) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["alias"]; !ok || v == nil {
		return fmt.Errorf("field alias in RequiredStorageDeposit: required")
	}
	if v, ok := raw["basic"]; !ok || v == nil {
		return fmt.Errorf("field basic in RequiredStorageDeposit: required")
	}
	if v, ok := raw["foundry"]; !ok || v == nil {
		return fmt.Errorf("field foundry in RequiredStorageDeposit: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft in RequiredStorageDeposit: required")
	}
	type Plain RequiredStorageDeposit
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RequiredStorageDeposit(plain)
	return nil
}


// A balance
type Balance struct {
	// Alias outputs
	Aliases []string `json:"aliases" yaml:"aliases" mapstructure:"aliases"`

	// The balance of the base coin
	BaseCoin BaseCoinBalance `json:"baseCoin" yaml:"baseCoin" mapstructure:"baseCoin"`

	// Foundry outputs
	Foundries []string `json:"foundries" yaml:"foundries" mapstructure:"foundries"`

	// The balance of the native tokens
	NativeTokens []NativeTokenBalance `json:"nativeTokens" yaml:"nativeTokens" mapstructure:"nativeTokens"`

	// Nft outputs
	Nfts []string `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// Outputs with multiple unlock conditions and if they can currently be spent or
	// not. If there is a TimelockUnlockCondition or ExpirationUnlockCondition this
	// can change at any time
	PotentiallyLockedOutputs BalancePotentiallyLockedOutputs `json:"potentiallyLockedOutputs" yaml:"potentiallyLockedOutputs" mapstructure:"potentiallyLockedOutputs"`

	// The required storage deposit for the outputs
	RequiredStorageDeposit RequiredStorageDeposit `json:"requiredStorageDeposit" yaml:"requiredStorageDeposit" mapstructure:"requiredStorageDeposit"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *Balance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliases"]; !ok || v == nil {
		return fmt.Errorf("field aliases in Balance: required")
	}
	if v, ok := raw["baseCoin"]; !ok || v == nil {
		return fmt.Errorf("field baseCoin in Balance: required")
	}
	if v, ok := raw["foundries"]; !ok || v == nil {
		return fmt.Errorf("field foundries in Balance: required")
	}
	if v, ok := raw["nativeTokens"]; !ok || v == nil {
		return fmt.Errorf("field nativeTokens in Balance: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts in Balance: required")
	}
	if v, ok := raw["potentiallyLockedOutputs"]; !ok || v == nil {
		return fmt.Errorf("field potentiallyLockedOutputs in Balance: required")
	}
	if v, ok := raw["requiredStorageDeposit"]; !ok || v == nil {
		return fmt.Errorf("field requiredStorageDeposit in Balance: required")
	}
	type Plain Balance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Balance(plain)
	return nil
}


type BasicOutputBuilderParamsFeaturesElem map[string]interface{}

type BasicOutputBuilderParamsUnlockConditionsElem map[string]interface{}

// Options for building a Basic Output
type BasicOutputBuilderParams struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features to be contained by the output.
	Features []BasicOutputBuilderParamsFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// The native tokens to be held by the output.
	NativeTokens []INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// The unlock conditions for the output.
	UnlockConditions []BasicOutputBuilderParamsUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BasicOutputBuilderParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in BasicOutputBuilderParams: required")
	}
	type Plain BasicOutputBuilderParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BasicOutputBuilderParams(plain)
	return nil
}


// The payload contents.
type BlockPayload map[string]interface{}

// Block layout.
type Block struct {
	// The nonce for the block.
	Nonce string `json:"nonce" yaml:"nonce" mapstructure:"nonce"`

	// The parent block ids.
	Parents []HexEncodedString `json:"parents" yaml:"parents" mapstructure:"parents"`

	// The payload contents.
	Payload BlockPayload `json:"payload,omitempty" yaml:"payload,omitempty" mapstructure:"payload,omitempty"`

	// The protocol version under which this block operates.
	ProtocolVersion float64 `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *Block) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nonce"]; !ok || v == nil {
		return fmt.Errorf("field nonce in Block: required")
	}
	if v, ok := raw["parents"]; !ok || v == nil {
		return fmt.Errorf("field parents in Block: required")
	}
	if v, ok := raw["protocolVersion"]; !ok || v == nil {
		return fmt.Errorf("field protocolVersion in Block: required")
	}
	type Plain Block
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Block(plain)
	return nil
}


// A block identifier, the BLAKE2b-256 hash of the block bytes. See
// <https://www.blake2.net/> for more information.
type BlockId string

type BuildAliasOutputDataFeaturesElem map[string]interface{}

type BuildAliasOutputDataImmutableFeaturesElem map[string]interface{}

type BuildAliasOutputDataStateMetadataBuffer struct {
	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildAliasOutputDataStateMetadataBuffer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in BuildAliasOutputDataStateMetadataBuffer: required")
	}
	type Plain BuildAliasOutputDataStateMetadataBuffer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildAliasOutputDataStateMetadataBuffer(plain)
	return nil
}


type BuildAliasOutputDataStateMetadata struct {
	// BYTESPERELEMENT corresponds to the JSON schema field "BYTES_PER_ELEMENT".
	BYTESPERELEMENT float64 `json:"BYTES_PER_ELEMENT" yaml:"BYTES_PER_ELEMENT" mapstructure:"BYTES_PER_ELEMENT"`

	// Buffer corresponds to the JSON schema field "buffer".
	Buffer BuildAliasOutputDataStateMetadataBuffer `json:"buffer" yaml:"buffer" mapstructure:"buffer"`

	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`

	// ByteOffset corresponds to the JSON schema field "byteOffset".
	ByteOffset float64 `json:"byteOffset" yaml:"byteOffset" mapstructure:"byteOffset"`

	// Length corresponds to the JSON schema field "length".
	Length float64 `json:"length" yaml:"length" mapstructure:"length"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildAliasOutputDataStateMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["BYTES_PER_ELEMENT"]; !ok || v == nil {
		return fmt.Errorf("field BYTES_PER_ELEMENT in BuildAliasOutputDataStateMetadata: required")
	}
	if v, ok := raw["buffer"]; !ok || v == nil {
		return fmt.Errorf("field buffer in BuildAliasOutputDataStateMetadata: required")
	}
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in BuildAliasOutputDataStateMetadata: required")
	}
	if v, ok := raw["byteOffset"]; !ok || v == nil {
		return fmt.Errorf("field byteOffset in BuildAliasOutputDataStateMetadata: required")
	}
	if v, ok := raw["length"]; !ok || v == nil {
		return fmt.Errorf("field length in BuildAliasOutputDataStateMetadata: required")
	}
	type Plain BuildAliasOutputDataStateMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildAliasOutputDataStateMetadata(plain)
	return nil
}


type BuildAliasOutputDataUnlockConditionsElem map[string]interface{}

// An alias output
type BuildAliasOutputData struct {
	// AliasId corresponds to the JSON schema field "aliasId".
	AliasId string `json:"aliasId" yaml:"aliasId" mapstructure:"aliasId"`

	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []BuildAliasOutputDataFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// FoundryCounter corresponds to the JSON schema field "foundryCounter".
	FoundryCounter float64 `json:"foundryCounter,omitempty" yaml:"foundryCounter,omitempty" mapstructure:"foundryCounter,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []BuildAliasOutputDataImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// NativeTokens corresponds to the JSON schema field "nativeTokens".
	NativeTokens *INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// StateIndex corresponds to the JSON schema field "stateIndex".
	StateIndex float64 `json:"stateIndex,omitempty" yaml:"stateIndex,omitempty" mapstructure:"stateIndex,omitempty"`

	// StateMetadata corresponds to the JSON schema field "stateMetadata".
	StateMetadata *BuildAliasOutputDataStateMetadata `json:"stateMetadata,omitempty" yaml:"stateMetadata,omitempty" mapstructure:"stateMetadata,omitempty"`

	// UnlockConditions corresponds to the JSON schema field "unlockConditions".
	UnlockConditions []BuildAliasOutputDataUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildAliasOutputData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliasId"]; !ok || v == nil {
		return fmt.Errorf("field aliasId in BuildAliasOutputData: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in BuildAliasOutputData: required")
	}
	type Plain BuildAliasOutputData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildAliasOutputData(plain)
	return nil
}


type BuildBasicOutputDataFeaturesElem map[string]interface{}

type BuildBasicOutputDataUnlockConditionsElem map[string]interface{}

// A basic output
type BuildBasicOutputData struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []BuildBasicOutputDataFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// NativeTokens corresponds to the JSON schema field "nativeTokens".
	NativeTokens *INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// UnlockConditions corresponds to the JSON schema field "unlockConditions".
	UnlockConditions []BuildBasicOutputDataUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildBasicOutputData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in BuildBasicOutputData: required")
	}
	type Plain BuildBasicOutputData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildBasicOutputData(plain)
	return nil
}


type BuildFoundryOutputDataFeaturesElem map[string]interface{}

type BuildFoundryOutputDataImmutableFeaturesElem map[string]interface{}

type BuildFoundryOutputDataTokenScheme map[string]interface{}

type BuildFoundryOutputDataUnlockConditionsElem map[string]interface{}

// A foundry output
type BuildFoundryOutputData struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []BuildFoundryOutputDataFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []BuildFoundryOutputDataImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// NativeTokens corresponds to the JSON schema field "nativeTokens".
	NativeTokens *INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// SerialNumber corresponds to the JSON schema field "serialNumber".
	SerialNumber float64 `json:"serialNumber" yaml:"serialNumber" mapstructure:"serialNumber"`

	// TokenScheme corresponds to the JSON schema field "tokenScheme".
	TokenScheme BuildFoundryOutputDataTokenScheme `json:"tokenScheme" yaml:"tokenScheme" mapstructure:"tokenScheme"`

	// UnlockConditions corresponds to the JSON schema field "unlockConditions".
	UnlockConditions []BuildFoundryOutputDataUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildFoundryOutputData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["serialNumber"]; !ok || v == nil {
		return fmt.Errorf("field serialNumber in BuildFoundryOutputData: required")
	}
	if v, ok := raw["tokenScheme"]; !ok || v == nil {
		return fmt.Errorf("field tokenScheme in BuildFoundryOutputData: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in BuildFoundryOutputData: required")
	}
	type Plain BuildFoundryOutputData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildFoundryOutputData(plain)
	return nil
}


type BuildNftOutputDataFeaturesElem map[string]interface{}

type BuildNftOutputDataImmutableFeaturesElem map[string]interface{}

type FaucetMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FaucetMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// An nft output
type BuildNftOutputData struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []BuildNftOutputDataFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []BuildNftOutputDataImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// NativeTokens corresponds to the JSON schema field "nativeTokens".
	NativeTokens *INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// UnlockConditions corresponds to the JSON schema field "unlockConditions".
	UnlockConditions []BuildNftOutputDataUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildNftOutputData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in BuildNftOutputData: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in BuildNftOutputData: required")
	}
	type Plain BuildNftOutputData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildNftOutputData(plain)
	return nil
}


// Amounts of native tokens to burn
type BurnNativeTokens struct {
	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnNativeTokens) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in BurnNativeTokens: required")
	}
	type Plain BurnNativeTokens
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BurnNativeTokens(plain)
	return nil
}


// A DTO for [`Burn`]
type Burn struct {
	// Aliases to burn
	Aliases []string `json:"aliases,omitempty" yaml:"aliases,omitempty" mapstructure:"aliases,omitempty"`

	// Foundries to burn
	Foundries []string `json:"foundries,omitempty" yaml:"foundries,omitempty" mapstructure:"foundries,omitempty"`

	// Amounts of native tokens to burn
	NativeTokens *BurnNativeTokens `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// NFTs to burn
	Nfts []string `json:"nfts,omitempty" yaml:"nfts,omitempty" mapstructure:"nfts,omitempty"`
}

// ChangeAddress variant of RemainderValueStrategy
type ChangeAddress struct {
	// Strategy corresponds to the JSON schema field "strategy".
	Strategy string `json:"strategy" yaml:"strategy" mapstructure:"strategy"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ChangeAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["strategy"]; !ok || v == nil {
		return fmt.Errorf("field strategy in ChangeAddress: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in ChangeAddress: required")
	}
	type Plain ChangeAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	if plain.Value != nil {
		return fmt.Errorf("field %s: must be null", "value")
	}
	*j = ChangeAddress(plain)
	return nil
}


type ConflictReason float64


// UnmarshalJSON implements json.Unmarshaler.
func (j *SubmitAndStoreTransactionMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["signedTransactionData"]; !ok || v == nil {
		return fmt.Errorf("field signedTransactionData in SubmitAndStoreTransactionMethodData: required")
	}
	type Plain SubmitAndStoreTransactionMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SubmitAndStoreTransactionMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ConflictReason) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_ConflictReason {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConflictReason, v)
	}
	*j = ConflictReason(v)
	return nil
}



// CustomAddress variant of RemainderValueStrategy
type CustomAddress struct {
	// Strategy corresponds to the JSON schema field "strategy".
	Strategy string `json:"strategy" yaml:"strategy" mapstructure:"strategy"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["strategy"]; !ok || v == nil {
		return fmt.Errorf("field strategy in CustomAddress: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in CustomAddress: required")
	}
	type Plain CustomAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = CustomAddress(plain)
	return nil
}


type EventStatus string


// UnmarshalJSON implements json.Unmarshaler.
func (j *EventStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_EventStatus {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventStatus, v)
	}
	*j = EventStatus(v)
	return nil
}


const EventStatusUpcoming EventStatus = "upcoming"
const EventStatusCommencing EventStatus = "commencing"
const EventStatusHolding EventStatus = "holding"
const EventStatusEnded EventStatus = "ended"
// Features to include in the output
type Features struct {
	// Issuer corresponds to the JSON schema field "issuer".
	Issuer string `json:"issuer,omitempty" yaml:"issuer,omitempty" mapstructure:"issuer,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata *HexEncodedString `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Sender corresponds to the JSON schema field "sender".
	Sender string `json:"sender,omitempty" yaml:"sender,omitempty" mapstructure:"sender,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *HexEncodedString `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type FilterOptionsOutputTypesBuffer struct {
	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FilterOptionsOutputTypesBuffer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in FilterOptionsOutputTypesBuffer: required")
	}
	type Plain FilterOptionsOutputTypesBuffer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FilterOptionsOutputTypesBuffer(plain)
	return nil
}


// Filter all outputs for the provided types (Basic = 3, Alias = 4, Foundry = 5,
// NFT = 6)
type FilterOptionsOutputTypes struct {
	// BYTESPERELEMENT corresponds to the JSON schema field "BYTES_PER_ELEMENT".
	BYTESPERELEMENT float64 `json:"BYTES_PER_ELEMENT" yaml:"BYTES_PER_ELEMENT" mapstructure:"BYTES_PER_ELEMENT"`

	// Buffer corresponds to the JSON schema field "buffer".
	Buffer FilterOptionsOutputTypesBuffer `json:"buffer" yaml:"buffer" mapstructure:"buffer"`

	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`

	// ByteOffset corresponds to the JSON schema field "byteOffset".
	ByteOffset float64 `json:"byteOffset" yaml:"byteOffset" mapstructure:"byteOffset"`

	// Length corresponds to the JSON schema field "length".
	Length float64 `json:"length" yaml:"length" mapstructure:"length"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FilterOptionsOutputTypes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["BYTES_PER_ELEMENT"]; !ok || v == nil {
		return fmt.Errorf("field BYTES_PER_ELEMENT in FilterOptionsOutputTypes: required")
	}
	if v, ok := raw["buffer"]; !ok || v == nil {
		return fmt.Errorf("field buffer in FilterOptionsOutputTypes: required")
	}
	if v, ok := raw["byteLength"]; !ok || v == nil {
		return fmt.Errorf("field byteLength in FilterOptionsOutputTypes: required")
	}
	if v, ok := raw["byteOffset"]; !ok || v == nil {
		return fmt.Errorf("field byteOffset in FilterOptionsOutputTypes: required")
	}
	if v, ok := raw["length"]; !ok || v == nil {
		return fmt.Errorf("field length in FilterOptionsOutputTypes: required")
	}
	type Plain FilterOptionsOutputTypes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FilterOptionsOutputTypes(plain)
	return nil
}


// Options to filter outputs
type FilterOptions struct {
	// Filter all outputs where the booked milestone index is below the specified
	// timestamp
	LowerBoundBookedTimestamp float64 `json:"lowerBoundBookedTimestamp,omitempty" yaml:"lowerBoundBookedTimestamp,omitempty" mapstructure:"lowerBoundBookedTimestamp,omitempty"`

	// Filter all outputs for the provided types (Basic = 3, Alias = 4, Foundry = 5,
	// NFT = 6)
	OutputTypes *FilterOptionsOutputTypes `json:"outputTypes,omitempty" yaml:"outputTypes,omitempty" mapstructure:"outputTypes,omitempty"`

	// Filter all outputs where the booked milestone index is above the specified
	// timestamp
	UpperBoundBookedTimestamp float64 `json:"upperBoundBookedTimestamp,omitempty" yaml:"upperBoundBookedTimestamp,omitempty" mapstructure:"upperBoundBookedTimestamp,omitempty"`
}

type FoundryOutputBuilderParamsFeaturesElem map[string]interface{}

type FoundryOutputBuilderParamsImmutableFeaturesElem map[string]interface{}

// Simple token scheme.
type FoundryOutputBuilderParamsTokenScheme map[string]interface{}

type FoundryOutputBuilderParamsUnlockConditionsElem map[string]interface{}

// Options for building a Foundry Output
type FoundryOutputBuilderParams struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features to be contained by the output.
	Features []FoundryOutputBuilderParamsFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []FoundryOutputBuilderParamsImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// The native tokens to be held by the output.
	NativeTokens []INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// The serial number of the foundry with respect to the controlling alias.
	SerialNumber float64 `json:"serialNumber" yaml:"serialNumber" mapstructure:"serialNumber"`

	// Simple token scheme.
	TokenScheme FoundryOutputBuilderParamsTokenScheme `json:"tokenScheme" yaml:"tokenScheme" mapstructure:"tokenScheme"`

	// The unlock conditions for the output.
	UnlockConditions []FoundryOutputBuilderParamsUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundryOutputBuilderParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["serialNumber"]; !ok || v == nil {
		return fmt.Errorf("field serialNumber in FoundryOutputBuilderParams: required")
	}
	if v, ok := raw["tokenScheme"]; !ok || v == nil {
		return fmt.Errorf("field tokenScheme in FoundryOutputBuilderParams: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in FoundryOutputBuilderParams: required")
	}
	type Plain FoundryOutputBuilderParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FoundryOutputBuilderParams(plain)
	return nil
}


// Query parameters for filtering Foundry Outputs
type FoundryQueryParameter interface{}


// Basic Auth or JWT.



// UnmarshalJSON implements json.Unmarshaler.
func (j *IAuth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	type Plain IAuth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	if len(plain.BasicAuthNamePwd) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "basicAuthNamePwd", 2)
	}
	if len(plain.BasicAuthNamePwd) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "basicAuthNamePwd", 2)
	}
	*j = IAuth(plain)
	return nil
}



// Block id response.
type IBlockIdResponse struct {
	// The block id.
	BlockId HexEncodedString `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IBlockIdResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in IBlockIdResponse: required")
	}
	type Plain IBlockIdResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IBlockIdResponse(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *StoreMnemonicMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["mnemonic"]; !ok || v == nil {
		return fmt.Errorf("field mnemonic in StoreMnemonicMethodData: required")
	}
	type Plain StoreMnemonicMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = StoreMnemonicMethodData(plain)
	return nil
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *LedgerInclusionState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_LedgerInclusionState {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LedgerInclusionState, v)
	}
	*j = LedgerInclusionState(v)
	return nil
}



// Response from the metadata endpoint.
type IBlockMetadata struct {
	// The block id.
	BlockId HexEncodedString `json:"blockId" yaml:"blockId" mapstructure:"blockId"`

	// The conflict reason.
	ConflictReason *ConflictReason `json:"conflictReason,omitempty" yaml:"conflictReason,omitempty" mapstructure:"conflictReason,omitempty"`

	// Is the block solid.
	IsSolid bool `json:"isSolid" yaml:"isSolid" mapstructure:"isSolid"`

	// The ledger inclusion state.
	LedgerInclusionState *LedgerInclusionState `json:"ledgerInclusionState,omitempty" yaml:"ledgerInclusionState,omitempty" mapstructure:"ledgerInclusionState,omitempty"`

	// Is this block a valid milestone.
	MilestoneIndex float64 `json:"milestoneIndex,omitempty" yaml:"milestoneIndex,omitempty" mapstructure:"milestoneIndex,omitempty"`

	// The parent block ids.
	Parents []HexEncodedString `json:"parents" yaml:"parents" mapstructure:"parents"`

	// Is the block referenced by a milestone.
	ReferencedByMilestoneIndex float64 `json:"referencedByMilestoneIndex,omitempty" yaml:"referencedByMilestoneIndex,omitempty" mapstructure:"referencedByMilestoneIndex,omitempty"`

	// Should the block be promoted.
	ShouldPromote bool `json:"shouldPromote,omitempty" yaml:"shouldPromote,omitempty" mapstructure:"shouldPromote,omitempty"`

	// Should the block be reattached.
	ShouldReattach bool `json:"shouldReattach,omitempty" yaml:"shouldReattach,omitempty" mapstructure:"shouldReattach,omitempty"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IBlockMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in IBlockMetadata: required")
	}
	if v, ok := raw["isSolid"]; !ok || v == nil {
		return fmt.Errorf("field isSolid in IBlockMetadata: required")
	}
	if v, ok := raw["parents"]; !ok || v == nil {
		return fmt.Errorf("field parents in IBlockMetadata: required")
	}
	type Plain IBlockMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IBlockMetadata(plain)
	return nil
}


// A range with start and end values.
type IRange struct {
	// End corresponds to the JSON schema field "end".
	End float64 `json:"end" yaml:"end" mapstructure:"end"`

	// Start corresponds to the JSON schema field "start".
	Start float64 `json:"start" yaml:"start" mapstructure:"start"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IRange) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in IRange: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in IRange: required")
	}
	type Plain IRange
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IRange(plain)
	return nil
}


// UTXO Transaction Input.
type IBuildBlockOptionsInputsElem struct {
	// The transaction Id.
	TransactionId HexEncodedString `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`

	// The input index.
	TransactionInputIndex float64 `json:"transactionInputIndex" yaml:"transactionInputIndex" mapstructure:"transactionInputIndex"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IBuildBlockOptionsInputsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in IBuildBlockOptionsInputsElem: required")
	}
	if v, ok := raw["transactionInputIndex"]; !ok || v == nil {
		return fmt.Errorf("field transactionInputIndex in IBuildBlockOptionsInputsElem: required")
	}
	type Plain IBuildBlockOptionsInputsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IBuildBlockOptionsInputsElem(plain)
	return nil
}


// Address with base coin amount
type IClientBlockBuilderOutputAddress struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IClientBlockBuilderOutputAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in IClientBlockBuilderOutputAddress: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in IClientBlockBuilderOutputAddress: required")
	}
	type Plain IClientBlockBuilderOutputAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IClientBlockBuilderOutputAddress(plain)
	return nil
}


type IBuildBlockOptionsOutputsElem map[string]interface{}

// Options to build a new block, possibly with payloads
type IBuildBlockOptions struct {
	// AccountIndex corresponds to the JSON schema field "accountIndex".
	AccountIndex float64 `json:"accountIndex,omitempty" yaml:"accountIndex,omitempty" mapstructure:"accountIndex,omitempty"`

	// Explicit burning of aliases, nfts, foundries and native tokens
	Burn *Burn `json:"burn,omitempty" yaml:"burn,omitempty" mapstructure:"burn,omitempty"`

	// CoinType corresponds to the JSON schema field "coinType".
	CoinType *CoinType `json:"coinType,omitempty" yaml:"coinType,omitempty" mapstructure:"coinType,omitempty"`

	// CustomRemainderAddress corresponds to the JSON schema field
	// "customRemainderAddress".
	CustomRemainderAddress string `json:"customRemainderAddress,omitempty" yaml:"customRemainderAddress,omitempty" mapstructure:"customRemainderAddress,omitempty"`

	// Data corresponds to the JSON schema field "data".
	Data string `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// InitialAddressIndex corresponds to the JSON schema field "initialAddressIndex".
	InitialAddressIndex float64 `json:"initialAddressIndex,omitempty" yaml:"initialAddressIndex,omitempty" mapstructure:"initialAddressIndex,omitempty"`

	// InputRange corresponds to the JSON schema field "inputRange".
	InputRange *IRange `json:"inputRange,omitempty" yaml:"inputRange,omitempty" mapstructure:"inputRange,omitempty"`

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []IBuildBlockOptionsInputsElem `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// Bech32 encoded output address and amount
	Output *IClientBlockBuilderOutputAddress `json:"output,omitempty" yaml:"output,omitempty" mapstructure:"output,omitempty"`

	// Hex encoded output address and amount
	OutputHex *IClientBlockBuilderOutputAddress `json:"outputHex,omitempty" yaml:"outputHex,omitempty" mapstructure:"outputHex,omitempty"`

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs []IBuildBlockOptionsOutputsElem `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Parent block IDs
	Parents []string `json:"parents,omitempty" yaml:"parents,omitempty" mapstructure:"parents,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}




// UnmarshalJSON implements json.Unmarshaler.
func (j *IDuration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nanos"]; !ok || v == nil {
		return fmt.Errorf("field nanos in IDuration: required")
	}
	if v, ok := raw["secs"]; !ok || v == nil {
		return fmt.Errorf("field secs in IDuration: required")
	}
	type Plain IDuration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IDuration(plain)
	return nil
}





// UnmarshalJSON implements json.Unmarshaler.
func (j *IRent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["vByteCost"]; !ok || v == nil {
		return fmt.Errorf("field vByteCost in IRent: required")
	}
	if v, ok := raw["vByteFactorData"]; !ok || v == nil {
		return fmt.Errorf("field vByteFactorData in IRent: required")
	}
	if v, ok := raw["vByteFactorKey"]; !ok || v == nil {
		return fmt.Errorf("field vByteFactorKey in IRent: required")
	}
	type Plain IRent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IRent(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoProtocol) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["bech32Hrp"]; !ok || v == nil {
		return fmt.Errorf("field bech32Hrp in INodeInfoProtocol: required")
	}
	if v, ok := raw["minPowScore"]; !ok || v == nil {
		return fmt.Errorf("field minPowScore in INodeInfoProtocol: required")
	}
	if v, ok := raw["networkName"]; !ok || v == nil {
		return fmt.Errorf("field networkName in INodeInfoProtocol: required")
	}
	if v, ok := raw["rentStructure"]; !ok || v == nil {
		return fmt.Errorf("field rentStructure in INodeInfoProtocol: required")
	}
	if v, ok := raw["tokenSupply"]; !ok || v == nil {
		return fmt.Errorf("field tokenSupply in INodeInfoProtocol: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in INodeInfoProtocol: required")
	}
	type Plain INodeInfoProtocol
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoProtocol(plain)
	return nil
}




// UnmarshalJSON implements json.Unmarshaler.
func (j *INetworkInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["fallbackToLocalPow"]; !ok || v == nil {
		return fmt.Errorf("field fallbackToLocalPow in INetworkInfo: required")
	}
	if v, ok := raw["localPow"]; !ok || v == nil {
		return fmt.Errorf("field localPow in INetworkInfo: required")
	}
	if v, ok := raw["minPowScore"]; !ok || v == nil {
		return fmt.Errorf("field minPowScore in INetworkInfo: required")
	}
	if v, ok := raw["protocolParameters"]; !ok || v == nil {
		return fmt.Errorf("field protocolParameters in INetworkInfo: required")
	}
	if v, ok := raw["tipsInterval"]; !ok || v == nil {
		return fmt.Errorf("field tipsInterval in INetworkInfo: required")
	}
	type Plain INetworkInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INetworkInfo(plain)
	return nil
}




// Gossip heartbeat.
type IGossipHeartbeat struct {
	// Connected peers.
	ConnectedPeers float64 `json:"connectedPeers" yaml:"connectedPeers" mapstructure:"connectedPeers"`

	// Latest milestone index.
	LatestMilestoneIndex float64 `json:"latestMilestoneIndex" yaml:"latestMilestoneIndex" mapstructure:"latestMilestoneIndex"`

	// Pruned milestone index.
	PrunedMilestoneIndex float64 `json:"prunedMilestoneIndex" yaml:"prunedMilestoneIndex" mapstructure:"prunedMilestoneIndex"`

	// Solid milestone index.
	SolidMilestoneIndex float64 `json:"solidMilestoneIndex" yaml:"solidMilestoneIndex" mapstructure:"solidMilestoneIndex"`

	// Synced peers.
	SyncedPeers float64 `json:"syncedPeers" yaml:"syncedPeers" mapstructure:"syncedPeers"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IGossipHeartbeat) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["connectedPeers"]; !ok || v == nil {
		return fmt.Errorf("field connectedPeers in IGossipHeartbeat: required")
	}
	if v, ok := raw["latestMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field latestMilestoneIndex in IGossipHeartbeat: required")
	}
	if v, ok := raw["prunedMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field prunedMilestoneIndex in IGossipHeartbeat: required")
	}
	if v, ok := raw["solidMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field solidMilestoneIndex in IGossipHeartbeat: required")
	}
	if v, ok := raw["syncedPeers"]; !ok || v == nil {
		return fmt.Errorf("field syncedPeers in IGossipHeartbeat: required")
	}
	type Plain IGossipHeartbeat
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IGossipHeartbeat(plain)
	return nil
}


// Gossip metrics.
type IGossipMetrics struct {
	// The number of dropped sent packets.
	DroppedPackets float64 `json:"droppedPackets" yaml:"droppedPackets" mapstructure:"droppedPackets"`

	// The number of known blocks.
	KnownBlocks float64 `json:"knownBlocks" yaml:"knownBlocks" mapstructure:"knownBlocks"`

	// The number of new blocks.
	NewBlocks float64 `json:"newBlocks" yaml:"newBlocks" mapstructure:"newBlocks"`

	// The number of received block requests.
	ReceivedBlockRequests float64 `json:"receivedBlockRequests" yaml:"receivedBlockRequests" mapstructure:"receivedBlockRequests"`

	// The number of received blocks.
	ReceivedBlocks float64 `json:"receivedBlocks" yaml:"receivedBlocks" mapstructure:"receivedBlocks"`

	// The number of received heartbeats.
	ReceivedHeartbeats float64 `json:"receivedHeartbeats" yaml:"receivedHeartbeats" mapstructure:"receivedHeartbeats"`

	// The number of received milestone requests.
	ReceivedMilestoneRequests float64 `json:"receivedMilestoneRequests" yaml:"receivedMilestoneRequests" mapstructure:"receivedMilestoneRequests"`

	// The number of sent block requests.
	SentBlockRequests float64 `json:"sentBlockRequests" yaml:"sentBlockRequests" mapstructure:"sentBlockRequests"`

	// The number of sent blocks.
	SentBlocks float64 `json:"sentBlocks" yaml:"sentBlocks" mapstructure:"sentBlocks"`

	// The number of sent heartbeats.
	SentHeartbeats float64 `json:"sentHeartbeats" yaml:"sentHeartbeats" mapstructure:"sentHeartbeats"`

	// The number of sent miletsone requests.
	SentMilestoneRequests float64 `json:"sentMilestoneRequests" yaml:"sentMilestoneRequests" mapstructure:"sentMilestoneRequests"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FaucetMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FaucetMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FaucetMethod: required")
	}
	type Plain FaucetMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FaucetMethod(plain)
	return nil
}









// Milestone.
type IMilestoneUtxoChangesResponse struct {
	// The output IDs (transaction hash + output index) of the consumed (spent)
	// outputs.
	ConsumedOutputs []HexEncodedString `json:"consumedOutputs" yaml:"consumedOutputs" mapstructure:"consumedOutputs"`

	// The output IDs (transaction hash + output index) of the newly created outputs.
	CreatedOutputs []HexEncodedString `json:"createdOutputs" yaml:"createdOutputs" mapstructure:"createdOutputs"`

	// The milestone index.
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IMilestoneUtxoChangesResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["consumedOutputs"]; !ok || v == nil {
		return fmt.Errorf("field consumedOutputs in IMilestoneUtxoChangesResponse: required")
	}
	if v, ok := raw["createdOutputs"]; !ok || v == nil {
		return fmt.Errorf("field createdOutputs in IMilestoneUtxoChangesResponse: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in IMilestoneUtxoChangesResponse: required")
	}
	type Plain IMilestoneUtxoChangesResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IMilestoneUtxoChangesResponse(plain)
	return nil
}


// A node object for the client.
type INode struct {
	// Auth corresponds to the JSON schema field "auth".
	Auth *IAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Disabled corresponds to the JSON schema field "disabled".
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in INode: required")
	}
	type Plain INode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INode(plain)
	return nil
}


// The base token info of the node.
type INodeInfoBaseToken struct {
	// The base token decimals.
	Decimals float64 `json:"decimals" yaml:"decimals" mapstructure:"decimals"`

	// The base token name.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The base token sub-unit.
	Subunit string `json:"subunit,omitempty" yaml:"subunit,omitempty" mapstructure:"subunit,omitempty"`

	// The base token ticker symbol.
	TickerSymbol string `json:"tickerSymbol" yaml:"tickerSymbol" mapstructure:"tickerSymbol"`

	// The base token unit.
	Unit string `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The use metric prefix flag.
	UseMetricPrefix bool `json:"useMetricPrefix" yaml:"useMetricPrefix" mapstructure:"useMetricPrefix"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoBaseToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["decimals"]; !ok || v == nil {
		return fmt.Errorf("field decimals in INodeInfoBaseToken: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in INodeInfoBaseToken: required")
	}
	if v, ok := raw["tickerSymbol"]; !ok || v == nil {
		return fmt.Errorf("field tickerSymbol in INodeInfoBaseToken: required")
	}
	if v, ok := raw["unit"]; !ok || v == nil {
		return fmt.Errorf("field unit in INodeInfoBaseToken: required")
	}
	if v, ok := raw["useMetricPrefix"]; !ok || v == nil {
		return fmt.Errorf("field useMetricPrefix in INodeInfoBaseToken: required")
	}
	type Plain INodeInfoBaseToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoBaseToken(plain)
	return nil
}


// Response from the /info endpoint.
type INodeInfoMetrics struct {
	// Blocks per second.
	BlocksPerSecond float64 `json:"blocksPerSecond" yaml:"blocksPerSecond" mapstructure:"blocksPerSecond"`

	// Referenced blocks per second.
	ReferencedBlocksPerSecond float64 `json:"referencedBlocksPerSecond" yaml:"referencedBlocksPerSecond" mapstructure:"referencedBlocksPerSecond"`

	// The rate at which rates are being referenced.
	ReferencedRate float64 `json:"referencedRate" yaml:"referencedRate" mapstructure:"referencedRate"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoMetrics) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blocksPerSecond"]; !ok || v == nil {
		return fmt.Errorf("field blocksPerSecond in INodeInfoMetrics: required")
	}
	if v, ok := raw["referencedBlocksPerSecond"]; !ok || v == nil {
		return fmt.Errorf("field referencedBlocksPerSecond in INodeInfoMetrics: required")
	}
	if v, ok := raw["referencedRate"]; !ok || v == nil {
		return fmt.Errorf("field referencedRate in INodeInfoMetrics: required")
	}
	type Plain INodeInfoMetrics
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoMetrics(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignTransactionMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["preparedTransactionData"]; !ok || v == nil {
		return fmt.Errorf("field preparedTransactionData in SignTransactionMethodData: required")
	}
	if v, ok := raw["secretManager"]; !ok || v == nil {
		return fmt.Errorf("field secretManager in SignTransactionMethodData: required")
	}
	type Plain SignTransactionMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignTransactionMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NodeInfoProtocolParamsMilestoneOpt) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in NodeInfoProtocolParamsMilestoneOpt: required")
	}
	if v, ok := raw["protocolVersion"]; !ok || v == nil {
		return fmt.Errorf("field protocolVersion in NodeInfoProtocolParamsMilestoneOpt: required")
	}
	if v, ok := raw["targetMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field targetMilestoneIndex in NodeInfoProtocolParamsMilestoneOpt: required")
	}
	type Plain NodeInfoProtocolParamsMilestoneOpt
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NodeInfoProtocolParamsMilestoneOpt(plain)
	return nil
}


// The milestone info.
type INodeInfoMilestone struct {
	// The milestone index.
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`

	// The milestone id.
	MilestoneId *HexEncodedString `json:"milestoneId,omitempty" yaml:"milestoneId,omitempty" mapstructure:"milestoneId,omitempty"`

	// The milestone timestamp.
	Timestamp float64 `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoMilestone) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in INodeInfoMilestone: required")
	}
	type Plain INodeInfoMilestone
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoMilestone(plain)
	return nil
}


// Response from the /info endpoint.
type INodeInfoStatus struct {
	// The confirmed milestone info.
	ConfirmedMilestone INodeInfoMilestone `json:"confirmedMilestone" yaml:"confirmedMilestone" mapstructure:"confirmedMilestone"`

	// Is the node healthy.
	IsHealthy bool `json:"isHealthy" yaml:"isHealthy" mapstructure:"isHealthy"`

	// The latest milestone info.
	LatestMilestone INodeInfoMilestone `json:"latestMilestone" yaml:"latestMilestone" mapstructure:"latestMilestone"`

	// The pruning index.
	PruningIndex float64 `json:"pruningIndex" yaml:"pruningIndex" mapstructure:"pruningIndex"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["confirmedMilestone"]; !ok || v == nil {
		return fmt.Errorf("field confirmedMilestone in INodeInfoStatus: required")
	}
	if v, ok := raw["isHealthy"]; !ok || v == nil {
		return fmt.Errorf("field isHealthy in INodeInfoStatus: required")
	}
	if v, ok := raw["latestMilestone"]; !ok || v == nil {
		return fmt.Errorf("field latestMilestone in INodeInfoStatus: required")
	}
	if v, ok := raw["pruningIndex"]; !ok || v == nil {
		return fmt.Errorf("field pruningIndex in INodeInfoStatus: required")
	}
	type Plain INodeInfoStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoStatus(plain)
	return nil
}


// Response from the /info endpoint.
type INodeInfo struct {
	// The base token info of the node.
	BaseToken INodeInfoBaseToken `json:"baseToken" yaml:"baseToken" mapstructure:"baseToken"`

	// Features supported by the node.
	Features []string `json:"features" yaml:"features" mapstructure:"features"`

	// The metrics for the node.
	Metrics INodeInfoMetrics `json:"metrics" yaml:"metrics" mapstructure:"metrics"`

	// The name of the node.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Pending protocol parameters.
	PendingProtocolParameters []NodeInfoProtocolParamsMilestoneOpt `json:"pendingProtocolParameters" yaml:"pendingProtocolParameters" mapstructure:"pendingProtocolParameters"`

	// The protocol info of the node.
	Protocol INodeInfoProtocol `json:"protocol" yaml:"protocol" mapstructure:"protocol"`

	// The status of the node.
	Status INodeInfoStatus `json:"status" yaml:"status" mapstructure:"status"`

	// The supported protocol versions.
	SupportedProtocolVersions []float64 `json:"supportedProtocolVersions" yaml:"supportedProtocolVersions" mapstructure:"supportedProtocolVersions"`

	// The version of node.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["baseToken"]; !ok || v == nil {
		return fmt.Errorf("field baseToken in INodeInfo: required")
	}
	if v, ok := raw["features"]; !ok || v == nil {
		return fmt.Errorf("field features in INodeInfo: required")
	}
	if v, ok := raw["metrics"]; !ok || v == nil {
		return fmt.Errorf("field metrics in INodeInfo: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in INodeInfo: required")
	}
	if v, ok := raw["pendingProtocolParameters"]; !ok || v == nil {
		return fmt.Errorf("field pendingProtocolParameters in INodeInfo: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol in INodeInfo: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status in INodeInfo: required")
	}
	if v, ok := raw["supportedProtocolVersions"]; !ok || v == nil {
		return fmt.Errorf("field supportedProtocolVersions in INodeInfo: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in INodeInfo: required")
	}
	type Plain INodeInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfo(plain)
	return nil
}


// NodeInfo wrapper which contains the node info and the url from the node (useful
// when multiple nodes are used)
type INodeInfoWrapper struct {
	// The node info
	NodeInfo INodeInfo `json:"nodeInfo" yaml:"nodeInfo" mapstructure:"nodeInfo"`

	// The url of the node
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *INodeInfoWrapper) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nodeInfo"]; !ok || v == nil {
		return fmt.Errorf("field nodeInfo in INodeInfoWrapper: required")
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in INodeInfoWrapper: required")
	}
	type Plain INodeInfoWrapper
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = INodeInfoWrapper(plain)
	return nil
}


// Details of an outputs response from the indexer plugin.
type IOutputsResponse struct {
	// The cursor to use for getting the next results.
	Cursor string `json:"cursor,omitempty" yaml:"cursor,omitempty" mapstructure:"cursor,omitempty"`

	// The output IDs (transaction hash + output index) of the outputs on this
	// address.
	Items []HexEncodedString `json:"items" yaml:"items" mapstructure:"items"`

	// The ledger index at which these outputs where available at.
	LedgerIndex float64 `json:"ledgerIndex" yaml:"ledgerIndex" mapstructure:"ledgerIndex"`

	// The maximum count of results that are returned by the node.
	PageSize string `json:"pageSize" yaml:"pageSize" mapstructure:"pageSize"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IOutputsResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["items"]; !ok || v == nil {
		return fmt.Errorf("field items in IOutputsResponse: required")
	}
	if v, ok := raw["ledgerIndex"]; !ok || v == nil {
		return fmt.Errorf("field ledgerIndex in IOutputsResponse: required")
	}
	if v, ok := raw["pageSize"]; !ok || v == nil {
		return fmt.Errorf("field pageSize in IOutputsResponse: required")
	}
	type Plain IOutputsResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IOutputsResponse(plain)
	return nil
}


// Gossip metrics for the peer.
type IPeerGossip struct {
	// The peer heartbeat.
	Heartbeat IGossipHeartbeat `json:"heartbeat" yaml:"heartbeat" mapstructure:"heartbeat"`

	// The peer metrics.
	Metrics IGossipMetrics `json:"metrics" yaml:"metrics" mapstructure:"metrics"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IPeerGossip) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["heartbeat"]; !ok || v == nil {
		return fmt.Errorf("field heartbeat in IPeerGossip: required")
	}
	if v, ok := raw["metrics"]; !ok || v == nil {
		return fmt.Errorf("field metrics in IPeerGossip: required")
	}
	type Plain IPeerGossip
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IPeerGossip(plain)
	return nil
}


// Peer details.
type IPeer struct {
	// The alias of the peer.
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" mapstructure:"alias,omitempty"`

	// Is it connected.
	Connected bool `json:"connected" yaml:"connected" mapstructure:"connected"`

	// Gossip metrics for the peer.
	Gossip *IPeerGossip `json:"gossip,omitempty" yaml:"gossip,omitempty" mapstructure:"gossip,omitempty"`

	// The id of the peer.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The addresses of the peer.
	MultiAddresses []string `json:"multiAddresses" yaml:"multiAddresses" mapstructure:"multiAddresses"`

	// The relation of the peer.
	Relation string `json:"relation" yaml:"relation" mapstructure:"relation"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IPeer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["connected"]; !ok || v == nil {
		return fmt.Errorf("field connected in IPeer: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in IPeer: required")
	}
	if v, ok := raw["multiAddresses"]; !ok || v == nil {
		return fmt.Errorf("field multiAddresses in IPeer: required")
	}
	if v, ok := raw["relation"]; !ok || v == nil {
		return fmt.Errorf("field relation in IPeer: required")
	}
	type Plain IPeer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IPeer(plain)
	return nil
}


// Optional error in the response.
type IResponseError struct {
	// The code for the error response.
	Code string `json:"code" yaml:"code" mapstructure:"code"`

	// A more descriptive version of the error.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IResponseError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["code"]; !ok || v == nil {
		return fmt.Errorf("field code in IResponseError: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in IResponseError: required")
	}
	type Plain IResponseError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IResponseError(plain)
	return nil
}


// Base response data.
type IResponse struct {
	// Optional error in the response.
	Error *IResponseError `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`
}

// Response from the /routes endpoint.
type IRoutesResponse struct {
	// The routes the node exposes.
	Routes []string `json:"routes" yaml:"routes" mapstructure:"routes"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IRoutesResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["routes"]; !ok || v == nil {
		return fmt.Errorf("field routes in IRoutesResponse: required")
	}
	type Plain IRoutesResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IRoutesResponse(plain)
	return nil
}


// Response from the tips endpoint.
type ITipsResponse struct {
	// The block ids of the tip.
	Tips []HexEncodedString `json:"tips" yaml:"tips" mapstructure:"tips"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ITipsResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["tips"]; !ok || v == nil {
		return fmt.Errorf("field tips in ITipsResponse: required")
	}
	type Plain ITipsResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ITipsResponse(plain)
	return nil
}


// The output




// UnmarshalJSON implements json.Unmarshaler.
func (j *InputSigningData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in InputSigningData: required")
	}
	if v, ok := raw["outputMetadata"]; !ok || v == nil {
		return fmt.Errorf("field outputMetadata in InputSigningData: required")
	}
	type Plain InputSigningData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = InputSigningData(plain)
	return nil
}






// UnmarshalJSON implements json.Unmarshaler.
func (j *SignTransactionEssenceMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SignTransactionEssenceMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignTransactionEssenceMethod: required")
	}
	type Plain SignTransactionEssenceMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignTransactionEssenceMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *LedgerDeviceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_LedgerDeviceType {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LedgerDeviceType, v)
	}
	*j = LedgerDeviceType(v)
	return nil
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in AccountAddress: required")
	}
	if v, ok := raw["internal"]; !ok || v == nil {
		return fmt.Errorf("field internal in AccountAddress: required")
	}
	if v, ok := raw["keyIndex"]; !ok || v == nil {
		return fmt.Errorf("field keyIndex in AccountAddress: required")
	}
	if v, ok := raw["used"]; !ok || v == nil {
		return fmt.Errorf("field used in AccountAddress: required")
	}
	type Plain AccountAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AccountAddress(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignTransactionEssenceMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["preparedTransactionData"]; !ok || v == nil {
		return fmt.Errorf("field preparedTransactionData in SignTransactionEssenceMethodData: required")
	}
	type Plain SignTransactionEssenceMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignTransactionEssenceMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *LedgerNanoSecretManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["ledgerNano"]; !ok || v == nil {
		return fmt.Errorf("field ledgerNano in LedgerNanoSecretManager: required")
	}
	type Plain LedgerNanoSecretManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = LedgerNanoSecretManager(plain)
	return nil
}




// UnmarshalJSON implements json.Unmarshaler.
func (j *MigratedFunds) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in MigratedFunds: required")
	}
	if v, ok := raw["deposit"]; !ok || v == nil {
		return fmt.Errorf("field deposit in MigratedFunds: required")
	}
	if v, ok := raw["tailTransactionHash"]; !ok || v == nil {
		return fmt.Errorf("field tailTransactionHash in MigratedFunds: required")
	}
	type Plain MigratedFunds
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MigratedFunds(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignEd25519MethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["chain"]; !ok || v == nil {
		return fmt.Errorf("field chain in SignEd25519MethodData: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in SignEd25519MethodData: required")
	}
	type Plain SignEd25519MethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignEd25519MethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignAndSubmitTransactionMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SignAndSubmitTransactionMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignAndSubmitTransactionMethod: required")
	}
	type Plain SignAndSubmitTransactionMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignAndSubmitTransactionMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReceiptMilestoneOptionTransactionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["milestoneId"]; !ok || v == nil {
		return fmt.Errorf("field milestoneId in ReceiptMilestoneOptionTransactionInput: required")
	}
	type Plain ReceiptMilestoneOptionTransactionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReceiptMilestoneOptionTransactionInput(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignAndSubmitTransactionMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["preparedTransactionData"]; !ok || v == nil {
		return fmt.Errorf("field preparedTransactionData in SignAndSubmitTransactionMethodData: required")
	}
	type Plain SignAndSubmitTransactionMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignAndSubmitTransactionMethodData(plain)
	return nil
}




// UnmarshalJSON implements json.Unmarshaler.
func (j *ReceiptMilestoneOptionTransaction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["input"]; !ok || v == nil {
		return fmt.Errorf("field input in ReceiptMilestoneOptionTransaction: required")
	}
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in ReceiptMilestoneOptionTransaction: required")
	}
	type Plain ReceiptMilestoneOptionTransaction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReceiptMilestoneOptionTransaction(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetStrongholdPasswordMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password in SetStrongholdPasswordMethodData: required")
	}
	type Plain SetStrongholdPasswordMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetStrongholdPasswordMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReceiptMilestoneOption) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["final"]; !ok || v == nil {
		return fmt.Errorf("field final in ReceiptMilestoneOption: required")
	}
	if v, ok := raw["funds"]; !ok || v == nil {
		return fmt.Errorf("field funds in ReceiptMilestoneOption: required")
	}
	if v, ok := raw["migratedAt"]; !ok || v == nil {
		return fmt.Errorf("field migratedAt in ReceiptMilestoneOption: required")
	}
	if v, ok := raw["transaction"]; !ok || v == nil {
		return fmt.Errorf("field transaction in ReceiptMilestoneOption: required")
	}
	type Plain ReceiptMilestoneOption
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReceiptMilestoneOption(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MilestoneReceipt) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["milestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndex in MilestoneReceipt: required")
	}
	if v, ok := raw["receipt"]; !ok || v == nil {
		return fmt.Errorf("field receipt in MilestoneReceipt: required")
	}
	type Plain MilestoneReceipt
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MilestoneReceipt(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetDefaultSyncOptionsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SetDefaultSyncOptionsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SetDefaultSyncOptionsMethod: required")
	}
	type Plain SetDefaultSyncOptionsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetDefaultSyncOptionsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNativeTokenParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["circulatingSupply"]; !ok || v == nil {
		return fmt.Errorf("field circulatingSupply in MintNativeTokenParams: required")
	}
	if v, ok := raw["maximumSupply"]; !ok || v == nil {
		return fmt.Errorf("field maximumSupply in MintNativeTokenParams: required")
	}
	type Plain MintNativeTokenParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MintNativeTokenParams(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetDefaultSyncOptionsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["options"]; !ok || v == nil {
		return fmt.Errorf("field options in SetDefaultSyncOptionsMethodData: required")
	}
	type Plain SetDefaultSyncOptionsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetDefaultSyncOptionsMethodData(plain)
	return nil
}




// UnmarshalJSON implements json.Unmarshaler.
func (j *MintTokenTransaction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in MintTokenTransaction: required")
	}
	if v, ok := raw["transaction"]; !ok || v == nil {
		return fmt.Errorf("field transaction in MintTokenTransaction: required")
	}
	type Plain MintTokenTransaction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MintTokenTransaction(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetClientOptionsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["clientOptions"]; !ok || v == nil {
		return fmt.Errorf("field clientOptions in SetClientOptionsMethodData: required")
	}
	type Plain SetClientOptionsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetClientOptionsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MnemonicSecretManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["mnemonic"]; !ok || v == nil {
		return fmt.Errorf("field mnemonic in MnemonicSecretManager: required")
	}
	type Plain MnemonicSecretManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MnemonicSecretManager(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAliasMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SetAliasMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SetAliasMethod: required")
	}
	type Plain SetAliasMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetAliasMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NamedParametersTypeofParsePayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in NamedParametersTypeofParsePayload: required")
	}
	type Plain NamedParametersTypeofParsePayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NamedParametersTypeofParsePayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAliasMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["alias"]; !ok || v == nil {
		return fmt.Errorf("field alias in SetAliasMethodData: required")
	}
	type Plain SetAliasMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SetAliasMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SendOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SendOutputsMethod: required")
	}
	type Plain SendOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendOutputsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *Network) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_Network {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Network, v)
	}
	*j = Network(v)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendOutputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputs"]; !ok || v == nil {
		return fmt.Errorf("field outputs in SendOutputsMethodData: required")
	}
	type Plain SendOutputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendOutputsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendAmountMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SendAmountMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SendAmountMethod: required")
	}
	type Plain SendAmountMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendAmountMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendAmountMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in SendAmountMethodData: required")
	}
	type Plain SendAmountMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendAmountMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryUntilIncludedMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in RetryUntilIncludedMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RetryUntilIncludedMethod: required")
	}
	type Plain RetryUntilIncludedMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryUntilIncludedMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftOutputBuilderParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in NftOutputBuilderParams: required")
	}
	if v, ok := raw["unlockConditions"]; !ok || v == nil {
		return fmt.Errorf("field unlockConditions in NftOutputBuilderParams: required")
	}
	type Plain NftOutputBuilderParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftOutputBuilderParams(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryUntilIncludedMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in RetryUntilIncludedMethodData: required")
	}
	type Plain RetryUntilIncludedMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryUntilIncludedMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryTransactionUntilIncludedMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in RetryTransactionUntilIncludedMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RetryTransactionUntilIncludedMethod: required")
	}
	type Plain RetryTransactionUntilIncludedMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryTransactionUntilIncludedMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryTransactionUntilIncludedMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in RetryTransactionUntilIncludedMethodData: required")
	}
	type Plain RetryTransactionUntilIncludedMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryTransactionUntilIncludedMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in RetryMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RetryMethod: required")
	}
	type Plain RetryMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReturnStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_ReturnStrategy {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReturnStrategy, v)
	}
	*j = ReturnStrategy(v)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in RetryMethodData: required")
	}
	type Plain RetryMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RetryMethodData(plain)
	return nil
}





// UnmarshalJSON implements json.Unmarshaler.
func (j *RestoreBackupMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password in RestoreBackupMethodData: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in RestoreBackupMethodData: required")
	}
	type Plain RestoreBackupMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RestoreBackupMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestFundsFromFaucetMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in RequestFundsFromFaucetMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RequestFundsFromFaucetMethod: required")
	}
	type Plain RequestFundsFromFaucetMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RequestFundsFromFaucetMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestFundsFromFaucetMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in RequestFundsFromFaucetMethodData: required")
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in RequestFundsFromFaucetMethodData: required")
	}
	type Plain RequestFundsFromFaucetMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RequestFundsFromFaucetMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in OutputParams: required")
	}
	if v, ok := raw["recipientAddress"]; !ok || v == nil {
		return fmt.Errorf("field recipientAddress in OutputParams: required")
	}
	type Plain OutputParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = OutputParams(plain)
	return nil
}





// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterParticipationEventsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in RegisterParticipationEventsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RegisterParticipationEventsMethod: required")
	}
	type Plain RegisterParticipationEventsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RegisterParticipationEventsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputsToClaim) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_OutputsToClaim {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OutputsToClaim, v)
	}
	*j = OutputsToClaim(v)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterParticipationEventsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["options"]; !ok || v == nil {
		return fmt.Errorf("field options in RegisterParticipationEventsMethodData: required")
	}
	type Plain RegisterParticipationEventsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RegisterParticipationEventsMethodData(plain)
	return nil
}






// UnmarshalJSON implements json.Unmarshaler.
func (j *RecoverAccountsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["accountGapLimit"]; !ok || v == nil {
		return fmt.Errorf("field accountGapLimit in RecoverAccountsMethodData: required")
	}
	if v, ok := raw["accountStartIndex"]; !ok || v == nil {
		return fmt.Errorf("field accountStartIndex in RecoverAccountsMethodData: required")
	}
	if v, ok := raw["addressGapLimit"]; !ok || v == nil {
		return fmt.Errorf("field addressGapLimit in RecoverAccountsMethodData: required")
	}
	type Plain RecoverAccountsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = RecoverAccountsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReattachUncheckedMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ReattachUncheckedMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ReattachUncheckedMethod: required")
	}
	type Plain ReattachUncheckedMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReattachUncheckedMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReattachUncheckedMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in ReattachUncheckedMethodData: required")
	}
	type Plain ReattachUncheckedMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReattachUncheckedMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReattachMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ReattachMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ReattachMethod: required")
	}
	type Plain ReattachMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReattachMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReattachMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in ReattachMethodData: required")
	}
	type Plain ReattachMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReattachMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEventData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["additionalInfo"]; !ok || v == nil {
		return fmt.Errorf("field additionalInfo in ParticipationEventData: required")
	}
	if v, ok := raw["milestoneIndexCommence"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndexCommence in ParticipationEventData: required")
	}
	if v, ok := raw["milestoneIndexEnd"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndexEnd in ParticipationEventData: required")
	}
	if v, ok := raw["milestoneIndexStart"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndexStart in ParticipationEventData: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ParticipationEventData: required")
	}
	if v, ok := raw["payload"]; !ok || v == nil {
		return fmt.Errorf("field payload in ParticipationEventData: required")
	}
	type Plain ParticipationEventData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationEventData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PromoteUncheckedMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PromoteUncheckedMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PromoteUncheckedMethod: required")
	}
	type Plain PromoteUncheckedMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PromoteUncheckedMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PromoteUncheckedMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in PromoteUncheckedMethodData: required")
	}
	type Plain PromoteUncheckedMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PromoteUncheckedMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ParticipationEvent: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in ParticipationEvent: required")
	}
	type Plain ParticipationEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationEvent(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PromoteMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PromoteMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PromoteMethod: required")
	}
	type Plain PromoteMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PromoteMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEventWithNodes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ParticipationEventWithNodes: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in ParticipationEventWithNodes: required")
	}
	if v, ok := raw["nodes"]; !ok || v == nil {
		return fmt.Errorf("field nodes in ParticipationEventWithNodes: required")
	}
	type Plain ParticipationEventWithNodes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationEventWithNodes(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PromoteMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in PromoteMethodData: required")
	}
	type Plain PromoteMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PromoteMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareVoteMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareVoteMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareVoteMethod: required")
	}
	type Plain PrepareVoteMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareVoteMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareTransactionMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareTransactionMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareTransactionMethod: required")
	}
	type Plain PrepareTransactionMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareTransactionMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEventRegistrationOptions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node in ParticipationEventRegistrationOptions: required")
	}
	type Plain ParticipationEventRegistrationOptions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationEventRegistrationOptions(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareStopParticipatingMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareStopParticipatingMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareStopParticipatingMethod: required")
	}
	type Plain PrepareStopParticipatingMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareStopParticipatingMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["answers"]; !ok || v == nil {
		return fmt.Errorf("field answers in QuestionStatus: required")
	}
	type Plain QuestionStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = QuestionStatus(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareStopParticipatingMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in PrepareStopParticipatingMethodData: required")
	}
	type Plain PrepareStopParticipatingMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareStopParticipatingMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEventStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["checksum"]; !ok || v == nil {
		return fmt.Errorf("field checksum in ParticipationEventStatus: required")
	}
	if v, ok := raw["milestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndex in ParticipationEventStatus: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status in ParticipationEventStatus: required")
	}
	type Plain ParticipationEventStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationEventStatus(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendNftMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareSendNftMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareSendNftMethod: required")
	}
	type Plain PrepareSendNftMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendNftMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendNftMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareSendNftMethodData: required")
	}
	type Plain PrepareSendNftMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendNftMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationEventType) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil { return err }
	var ok bool
	for _, expected := range enumValues_ParticipationEventType {
	if reflect.DeepEqual(v, expected) { ok = true; break }
	}
	if !ok {
	return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParticipationEventType, v)
	}
	*j = ParticipationEventType(v)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendNativeTokensMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareSendNativeTokensMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareSendNativeTokensMethod: required")
	}
	type Plain PrepareSendNativeTokensMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendNativeTokensMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TrackedParticipationOverview) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in TrackedParticipationOverview: required")
	}
	if v, ok := raw["answers"]; !ok || v == nil {
		return fmt.Errorf("field answers in TrackedParticipationOverview: required")
	}
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in TrackedParticipationOverview: required")
	}
	if v, ok := raw["endMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field endMilestoneIndex in TrackedParticipationOverview: required")
	}
	if v, ok := raw["startMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field startMilestoneIndex in TrackedParticipationOverview: required")
	}
	type Plain TrackedParticipationOverview
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TrackedParticipationOverview(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendNativeTokensMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareSendNativeTokensMethodData: required")
	}
	type Plain PrepareSendNativeTokensMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendNativeTokensMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendAmountMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareSendAmountMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareSendAmountMethod: required")
	}
	type Plain PrepareSendAmountMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendAmountMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParticipationOverview) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["participations"]; !ok || v == nil {
		return fmt.Errorf("field participations in ParticipationOverview: required")
	}
	type Plain ParticipationOverview
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParticipationOverview(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareSendAmountMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareSendAmountMethodData: required")
	}
	type Plain PrepareSendAmountMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareSendAmountMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareOutputMethod: required")
	}
	type Plain PrepareOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareOutputMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareOutputMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareOutputMethodData: required")
	}
	type Plain PrepareOutputMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareOutputMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareMintNftsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareMintNftsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareMintNftsMethod: required")
	}
	type Plain PrepareMintNftsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareMintNftsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareMintNftsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareMintNftsMethodData: required")
	}
	type Plain PrepareMintNftsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareMintNftsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareMintNativeTokenMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareMintNativeTokenMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareMintNativeTokenMethod: required")
	}
	type Plain PrepareMintNativeTokenMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareMintNativeTokenMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *Remainder) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in Remainder: required")
	}
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in Remainder: required")
	}
	type Plain Remainder
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Remainder(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareMintNativeTokenMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in PrepareMintNativeTokenMethodData: required")
	}
	type Plain PrepareMintNativeTokenMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareMintNativeTokenMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PreparedTransactionData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["essence"]; !ok || v == nil {
		return fmt.Errorf("field essence in PreparedTransactionData: required")
	}
	if v, ok := raw["inputsData"]; !ok || v == nil {
		return fmt.Errorf("field inputsData in PreparedTransactionData: required")
	}
	type Plain PreparedTransactionData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PreparedTransactionData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareIncreaseVotingPowerMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareIncreaseVotingPowerMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareIncreaseVotingPowerMethod: required")
	}
	type Plain PrepareIncreaseVotingPowerMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareIncreaseVotingPowerMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PreparedMintTokenTransactionData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in PreparedMintTokenTransactionData: required")
	}
	if v, ok := raw["transaction"]; !ok || v == nil {
		return fmt.Errorf("field transaction in PreparedMintTokenTransactionData: required")
	}
	type Plain PreparedMintTokenTransactionData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PreparedMintTokenTransactionData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareIncreaseVotingPowerMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in PrepareIncreaseVotingPowerMethodData: required")
	}
	type Plain PrepareIncreaseVotingPowerMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareIncreaseVotingPowerMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareIncreaseNativeTokenSupplyMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareIncreaseNativeTokenSupplyMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareIncreaseNativeTokenSupplyMethod: required")
	}
	type Plain PrepareIncreaseNativeTokenSupplyMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareIncreaseNativeTokenSupplyMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ProtocolParamsMilestoneOption) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params in ProtocolParamsMilestoneOption: required")
	}
	if v, ok := raw["protocolVersion"]; !ok || v == nil {
		return fmt.Errorf("field protocolVersion in ProtocolParamsMilestoneOption: required")
	}
	if v, ok := raw["targetMilestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field targetMilestoneIndex in ProtocolParamsMilestoneOption: required")
	}
	type Plain ProtocolParamsMilestoneOption
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ProtocolParamsMilestoneOption(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareIncreaseNativeTokenSupplyMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["mintAmount"]; !ok || v == nil {
		return fmt.Errorf("field mintAmount in PrepareIncreaseNativeTokenSupplyMethodData: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in PrepareIncreaseNativeTokenSupplyMethodData: required")
	}
	type Plain PrepareIncreaseNativeTokenSupplyMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareIncreaseNativeTokenSupplyMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareDecreaseVotingPowerMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareDecreaseVotingPowerMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareDecreaseVotingPowerMethod: required")
	}
	type Plain PrepareDecreaseVotingPowerMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareDecreaseVotingPowerMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *Question) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["additionalInfo"]; !ok || v == nil {
		return fmt.Errorf("field additionalInfo in Question: required")
	}
	if v, ok := raw["answers"]; !ok || v == nil {
		return fmt.Errorf("field answers in Question: required")
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in Question: required")
	}
	type Plain Question
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Question(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareDecreaseVotingPowerMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in PrepareDecreaseVotingPowerMethodData: required")
	}
	type Plain PrepareDecreaseVotingPowerMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareDecreaseVotingPowerMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReceiptsResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["receipts"]; !ok || v == nil {
		return fmt.Errorf("field receipts in ReceiptsResponse: required")
	}
	type Plain ReceiptsResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ReceiptsResponse(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareDecreaseNativeTokenSupplyMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareDecreaseNativeTokenSupplyMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareDecreaseNativeTokenSupplyMethod: required")
	}
	type Plain PrepareDecreaseNativeTokenSupplyMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareDecreaseNativeTokenSupplyMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareDecreaseNativeTokenSupplyMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["meltAmount"]; !ok || v == nil {
		return fmt.Errorf("field meltAmount in PrepareDecreaseNativeTokenSupplyMethodData: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in PrepareDecreaseNativeTokenSupplyMethodData: required")
	}
	type Plain PrepareDecreaseNativeTokenSupplyMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareDecreaseNativeTokenSupplyMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ReuseAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["strategy"]; !ok || v == nil {
		return fmt.Errorf("field strategy in ReuseAddress: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in ReuseAddress: required")
	}
	type Plain ReuseAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	if plain.Value != nil {
		return fmt.Errorf("field %s: must be null", "value")
	}
	*j = ReuseAddress(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareCreateAliasOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareCreateAliasOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareCreateAliasOutputMethod: required")
	}
	type Plain PrepareCreateAliasOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareCreateAliasOutputMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *Secp256K1EcdsaSignature) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["publicKey"]; !ok || v == nil {
		return fmt.Errorf("field publicKey in Secp256K1EcdsaSignature: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in Secp256K1EcdsaSignature: required")
	}
	type Plain Secp256K1EcdsaSignature
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Secp256K1EcdsaSignature(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareConsolidateOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareConsolidateOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareConsolidateOutputsMethod: required")
	}
	type Plain PrepareConsolidateOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareConsolidateOutputsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareConsolidateOutputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["force"]; !ok || v == nil {
		return fmt.Errorf("field force in PrepareConsolidateOutputsMethodData: required")
	}
	type Plain PrepareConsolidateOutputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareConsolidateOutputsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SeedSecretManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["hexSeed"]; !ok || v == nil {
		return fmt.Errorf("field hexSeed in SeedSecretManager: required")
	}
	type Plain SeedSecretManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SeedSecretManager(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareBurnMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PrepareBurnMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PrepareBurnMethod: required")
	}
	type Plain PrepareBurnMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareBurnMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendAmountParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in SendAmountParams: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in SendAmountParams: required")
	}
	type Plain SendAmountParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendAmountParams(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PrepareBurnMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["burn"]; !ok || v == nil {
		return fmt.Errorf("field burn in PrepareBurnMethodData: required")
	}
	type Plain PrepareBurnMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PrepareBurnMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendNativeTokensParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in SendNativeTokensParams: required")
	}
	type Plain SendNativeTokensParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendNativeTokensParams(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockRawMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PostBlockRawMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PostBlockRawMethod: required")
	}
	type Plain PostBlockRawMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockRawMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SendNftParams) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in SendNftParams: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in SendNftParams: required")
	}
	type Plain SendNftParams
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SendNftParams(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockRawMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["block"]; !ok || v == nil {
		return fmt.Errorf("field block in PostBlockRawMethodData: required")
	}
	type Plain PostBlockRawMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockRawMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockPayloadMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PostBlockPayloadMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PostBlockPayloadMethod: required")
	}
	type Plain PostBlockPayloadMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockPayloadMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockPayloadMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["payload"]; !ok || v == nil {
		return fmt.Errorf("field payload in PostBlockPayloadMethodData: required")
	}
	type Plain PostBlockPayloadMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockPayloadMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedTransactionEssenceTransactionPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["essence"]; !ok || v == nil {
		return fmt.Errorf("field essence in SignedTransactionEssenceTransactionPayload: required")
	}
	if v, ok := raw["unlocks"]; !ok || v == nil {
		return fmt.Errorf("field unlocks in SignedTransactionEssenceTransactionPayload: required")
	}
	type Plain SignedTransactionEssenceTransactionPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignedTransactionEssenceTransactionPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PostBlockMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PostBlockMethod: required")
	}
	type Plain PostBlockMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedTransactionEssence) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["inputsData"]; !ok || v == nil {
		return fmt.Errorf("field inputsData in SignedTransactionEssence: required")
	}
	if v, ok := raw["transactionPayload"]; !ok || v == nil {
		return fmt.Errorf("field transactionPayload in SignedTransactionEssence: required")
	}
	type Plain SignedTransactionEssence
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = SignedTransactionEssence(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PostBlockMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["block"]; !ok || v == nil {
		return fmt.Errorf("field block in PostBlockMethodData: required")
	}
	type Plain PostBlockMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PostBlockMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *StakingEventPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["additionalInfo"]; !ok || v == nil {
		return fmt.Errorf("field additionalInfo in StakingEventPayload: required")
	}
	if v, ok := raw["denominator"]; !ok || v == nil {
		return fmt.Errorf("field denominator in StakingEventPayload: required")
	}
	if v, ok := raw["numerator"]; !ok || v == nil {
		return fmt.Errorf("field numerator in StakingEventPayload: required")
	}
	if v, ok := raw["requiredMinimumRewards"]; !ok || v == nil {
		return fmt.Errorf("field requiredMinimumRewards in StakingEventPayload: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol in StakingEventPayload: required")
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in StakingEventPayload: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in StakingEventPayload: required")
	}
	type Plain StakingEventPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = StakingEventPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *PendingTransactionsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in PendingTransactionsMethod: required")
	}
	type Plain PendingTransactionsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = PendingTransactionsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParseBech32AddressMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ParseBech32AddressMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ParseBech32AddressMethod: required")
	}
	type Plain ParseBech32AddressMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParseBech32AddressMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *StrongholdSecretManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["stronghold"]; !ok || v == nil {
		return fmt.Errorf("field stronghold in StrongholdSecretManager: required")
	}
	type Plain StrongholdSecretManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = StrongholdSecretManager(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *ParseBech32AddressMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in ParseBech32AddressMethodData: required")
	}
	type Plain ParseBech32AddressMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ParseBech32AddressMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in OutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in OutputsMethod: required")
	}
	type Plain OutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = OutputsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftOutputIdsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in NftOutputIdsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in NftOutputIdsMethod: required")
	}
	type Plain NftOutputIdsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftOutputIdsMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftOutputIdsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["queryParameters"]; !ok || v == nil {
		return fmt.Errorf("field queryParameters in NftOutputIdsMethodData: required")
	}
	type Plain NftOutputIdsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftOutputIdsMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionOptionsTaggedDataPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in TransactionOptionsTaggedDataPayload: required")
	}
	if v, ok := raw["tag"]; !ok || v == nil {
		return fmt.Errorf("field tag in TransactionOptionsTaggedDataPayload: required")
	}
	type Plain TransactionOptionsTaggedDataPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionOptionsTaggedDataPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftOutputIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in NftOutputIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in NftOutputIdMethod: required")
	}
	type Plain NftOutputIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftOutputIdMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionOptions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["allowMicroAmount"]; !ok || v == nil {
		return fmt.Errorf("field allowMicroAmount in TransactionOptions: required")
	}
	type Plain TransactionOptions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = TransactionOptions(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftOutputIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in NftOutputIdMethodData: required")
	}
	type Plain NftOutputIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftOutputIdMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *VotingEventPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["questions"]; !ok || v == nil {
		return fmt.Errorf("field questions in VotingEventPayload: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in VotingEventPayload: required")
	}
	type Plain VotingEventPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = VotingEventPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftIdToBech32Method) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in NftIdToBech32Method: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in NftIdToBech32Method: required")
	}
	type Plain NftIdToBech32Method
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftIdToBech32Method(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *NftIdToBech32MethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in NftIdToBech32MethodData: required")
	}
	type Plain NftIdToBech32MethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = NftIdToBech32MethodData(plain)
	return nil
}


type AccountMethod interface{}

type AddressesMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AddressesMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AddressesMethod: required")
	}
	type Plain AddressesMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AddressesMethod(plain)
	return nil
}


type AddressesWithUnspentOutputsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AddressesWithUnspentOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AddressesWithUnspentOutputsMethod: required")
	}
	type Plain AddressesWithUnspentOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AddressesWithUnspentOutputsMethod(plain)
	return nil
}


type AliasIdToBech32MethodData struct {
	// AliasId corresponds to the JSON schema field "aliasId".
	AliasId string `json:"aliasId" yaml:"aliasId" mapstructure:"aliasId"`

	// Bech32Hrp corresponds to the JSON schema field "bech32Hrp".
	Bech32Hrp string `json:"bech32Hrp,omitempty" yaml:"bech32Hrp,omitempty" mapstructure:"bech32Hrp,omitempty"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasIdToBech32MethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliasId"]; !ok || v == nil {
		return fmt.Errorf("field aliasId in AliasIdToBech32MethodData: required")
	}
	type Plain AliasIdToBech32MethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasIdToBech32MethodData(plain)
	return nil
}


type AliasIdToBech32Method struct {
	// Data corresponds to the JSON schema field "data".
	Data AliasIdToBech32MethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasIdToBech32Method) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in AliasIdToBech32Method: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AliasIdToBech32Method: required")
	}
	type Plain AliasIdToBech32Method
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasIdToBech32Method(plain)
	return nil
}


type AliasOutputIdMethodData struct {
	// AliasId corresponds to the JSON schema field "aliasId".
	AliasId string `json:"aliasId" yaml:"aliasId" mapstructure:"aliasId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasOutputIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliasId"]; !ok || v == nil {
		return fmt.Errorf("field aliasId in AliasOutputIdMethodData: required")
	}
	type Plain AliasOutputIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasOutputIdMethodData(plain)
	return nil
}


type AliasOutputIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data AliasOutputIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasOutputIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in AliasOutputIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AliasOutputIdMethod: required")
	}
	type Plain AliasOutputIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasOutputIdMethod(plain)
	return nil
}


type AliasOutputIdsMethodDataQueryParametersElem interface{}

type AliasOutputIdsMethodData struct {
	// QueryParameters corresponds to the JSON schema field "queryParameters".
	QueryParameters []AliasOutputIdsMethodDataQueryParametersElem `json:"queryParameters" yaml:"queryParameters" mapstructure:"queryParameters"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasOutputIdsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["queryParameters"]; !ok || v == nil {
		return fmt.Errorf("field queryParameters in AliasOutputIdsMethodData: required")
	}
	type Plain AliasOutputIdsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasOutputIdsMethodData(plain)
	return nil
}


type AliasOutputIdsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data AliasOutputIdsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *AliasOutputIdsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in AliasOutputIdsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AliasOutputIdsMethod: required")
	}
	type Plain AliasOutputIdsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = AliasOutputIdsMethod(plain)
	return nil
}


type Bech32ToHexMethodData struct {
	// Bech32 corresponds to the JSON schema field "bech32".
	Bech32 string `json:"bech32" yaml:"bech32" mapstructure:"bech32"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *Bech32ToHexMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["bech32"]; !ok || v == nil {
		return fmt.Errorf("field bech32 in Bech32ToHexMethodData: required")
	}
	type Plain Bech32ToHexMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Bech32ToHexMethodData(plain)
	return nil
}


type Bech32ToHexMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data Bech32ToHexMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *Bech32ToHexMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in Bech32ToHexMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Bech32ToHexMethod: required")
	}
	type Plain Bech32ToHexMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = Bech32ToHexMethod(plain)
	return nil
}


type BlockIdMethodData struct {
	// Block corresponds to the JSON schema field "block".
	Block Block `json:"block" yaml:"block" mapstructure:"block"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["block"]; !ok || v == nil {
		return fmt.Errorf("field block in BlockIdMethodData: required")
	}
	type Plain BlockIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BlockIdMethodData(plain)
	return nil
}


type BlockIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data BlockIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BlockIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BlockIdMethod: required")
	}
	type Plain BlockIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BlockIdMethod(plain)
	return nil
}


type BuildAliasOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data AliasOutputBuilderParams `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildAliasOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BuildAliasOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BuildAliasOutputMethod: required")
	}
	type Plain BuildAliasOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildAliasOutputMethod(plain)
	return nil
}


type BuildAndPostBlockMethodDataSecretManager interface{}

type BuildAndPostBlockMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *IBuildBlockOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// SecretManager corresponds to the JSON schema field "secretManager".
	SecretManager BuildAndPostBlockMethodDataSecretManager `json:"secretManager,omitempty" yaml:"secretManager,omitempty" mapstructure:"secretManager,omitempty"`
}

type BuildAndPostBlockMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data BuildAndPostBlockMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildAndPostBlockMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BuildAndPostBlockMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BuildAndPostBlockMethod: required")
	}
	type Plain BuildAndPostBlockMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildAndPostBlockMethod(plain)
	return nil
}


type BuildBasicOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data BasicOutputBuilderParams `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildBasicOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BuildBasicOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BuildBasicOutputMethod: required")
	}
	type Plain BuildBasicOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildBasicOutputMethod(plain)
	return nil
}


type BuildFoundryOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FoundryOutputBuilderParams `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildFoundryOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BuildFoundryOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BuildFoundryOutputMethod: required")
	}
	type Plain BuildFoundryOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildFoundryOutputMethod(plain)
	return nil
}


type BuildNftOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data NftOutputBuilderParams `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildNftOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in BuildNftOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in BuildNftOutputMethod: required")
	}
	type Plain BuildNftOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = BuildNftOutputMethod(plain)
	return nil
}


type CallAccountMethodMethodDataMethod interface{}

type CallAccountMethodMethodData struct {
	// AccountId corresponds to the JSON schema field "accountId".
	AccountId AccountId `json:"accountId" yaml:"accountId" mapstructure:"accountId"`

	// Method corresponds to the JSON schema field "method".
	Method CallAccountMethodMethodDataMethod `json:"method" yaml:"method" mapstructure:"method"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *CallAccountMethodMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["accountId"]; !ok || v == nil {
		return fmt.Errorf("field accountId in CallAccountMethodMethodData: required")
	}
	if v, ok := raw["method"]; !ok || v == nil {
		return fmt.Errorf("field method in CallAccountMethodMethodData: required")
	}
	type Plain CallAccountMethodMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = CallAccountMethodMethodData(plain)
	return nil
}


type CallAccountMethodMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data CallAccountMethodMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *CallAccountMethodMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in CallAccountMethodMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in CallAccountMethodMethod: required")
	}
	type Plain CallAccountMethodMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = CallAccountMethodMethod(plain)
	return nil
}







type ClaimOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ClaimOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ClaimOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ClaimOutputsMethod: required")
	}
	type Plain ClaimOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ClaimOutputsMethod(plain)
	return nil
}


type ClaimableOutputsMethodData struct {
	// OutputsToClaim corresponds to the JSON schema field "outputsToClaim".
	OutputsToClaim OutputsToClaim `json:"outputsToClaim" yaml:"outputsToClaim" mapstructure:"outputsToClaim"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimableOutputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputsToClaim"]; !ok || v == nil {
		return fmt.Errorf("field outputsToClaim in ClaimableOutputsMethodData: required")
	}
	type Plain ClaimableOutputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ClaimableOutputsMethodData(plain)
	return nil
}


type ClaimableOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ClaimableOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ClaimableOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ClaimableOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ClaimableOutputsMethod: required")
	}
	type Plain ClaimableOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ClaimableOutputsMethod(plain)
	return nil
}




type ClientMethods interface{}

type ComputeAliasIdMethodData struct {
	// OutputId corresponds to the JSON schema field "outputId".
	OutputId string `json:"outputId" yaml:"outputId" mapstructure:"outputId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeAliasIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputId"]; !ok || v == nil {
		return fmt.Errorf("field outputId in ComputeAliasIdMethodData: required")
	}
	type Plain ComputeAliasIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeAliasIdMethodData(plain)
	return nil
}


type ComputeAliasIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ComputeAliasIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeAliasIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ComputeAliasIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ComputeAliasIdMethod: required")
	}
	type Plain ComputeAliasIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeAliasIdMethod(plain)
	return nil
}


type ComputeFoundryIdMethodData struct {
	// AliasAddress corresponds to the JSON schema field "aliasAddress".
	AliasAddress string `json:"aliasAddress" yaml:"aliasAddress" mapstructure:"aliasAddress"`

	// SerialNumber corresponds to the JSON schema field "serialNumber".
	SerialNumber float64 `json:"serialNumber" yaml:"serialNumber" mapstructure:"serialNumber"`

	// TokenSchemeKind corresponds to the JSON schema field "tokenSchemeKind".
	TokenSchemeKind float64 `json:"tokenSchemeKind" yaml:"tokenSchemeKind" mapstructure:"tokenSchemeKind"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeFoundryIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["aliasAddress"]; !ok || v == nil {
		return fmt.Errorf("field aliasAddress in ComputeFoundryIdMethodData: required")
	}
	if v, ok := raw["serialNumber"]; !ok || v == nil {
		return fmt.Errorf("field serialNumber in ComputeFoundryIdMethodData: required")
	}
	if v, ok := raw["tokenSchemeKind"]; !ok || v == nil {
		return fmt.Errorf("field tokenSchemeKind in ComputeFoundryIdMethodData: required")
	}
	type Plain ComputeFoundryIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeFoundryIdMethodData(plain)
	return nil
}


type ComputeFoundryIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ComputeFoundryIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeFoundryIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ComputeFoundryIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ComputeFoundryIdMethod: required")
	}
	type Plain ComputeFoundryIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeFoundryIdMethod(plain)
	return nil
}


type ComputeNftIdMethodData struct {
	// OutputId corresponds to the JSON schema field "outputId".
	OutputId string `json:"outputId" yaml:"outputId" mapstructure:"outputId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeNftIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputId"]; !ok || v == nil {
		return fmt.Errorf("field outputId in ComputeNftIdMethodData: required")
	}
	type Plain ComputeNftIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeNftIdMethodData(plain)
	return nil
}


type ComputeNftIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ComputeNftIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ComputeNftIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ComputeNftIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ComputeNftIdMethod: required")
	}
	type Plain ComputeNftIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ComputeNftIdMethod(plain)
	return nil
}


type ConsolidateFundsMethodDataSecretManager interface{}

type ConsolidateFundsMethodData struct {
	// GenerateAddressesOptions corresponds to the JSON schema field
	// "generateAddressesOptions".
	GenerateAddressesOptions IGenerateAddressesOptions `json:"generateAddressesOptions" yaml:"generateAddressesOptions" mapstructure:"generateAddressesOptions"`

	// SecretManager corresponds to the JSON schema field "secretManager".
	SecretManager ConsolidateFundsMethodDataSecretManager `json:"secretManager" yaml:"secretManager" mapstructure:"secretManager"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsolidateFundsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["generateAddressesOptions"]; !ok || v == nil {
		return fmt.Errorf("field generateAddressesOptions in ConsolidateFundsMethodData: required")
	}
	if v, ok := raw["secretManager"]; !ok || v == nil {
		return fmt.Errorf("field secretManager in ConsolidateFundsMethodData: required")
	}
	type Plain ConsolidateFundsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ConsolidateFundsMethodData(plain)
	return nil
}


type ConsolidateFundsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ConsolidateFundsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsolidateFundsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ConsolidateFundsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ConsolidateFundsMethod: required")
	}
	type Plain ConsolidateFundsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = ConsolidateFundsMethod(plain)
	return nil
}



type DeregisterParticipationEventMethodData struct {
	// EventId corresponds to the JSON schema field "eventId".
	EventId ParticipationEventId `json:"eventId" yaml:"eventId" mapstructure:"eventId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *DeregisterParticipationEventMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in DeregisterParticipationEventMethodData: required")
	}
	type Plain DeregisterParticipationEventMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = DeregisterParticipationEventMethodData(plain)
	return nil
}


type DeregisterParticipationEventMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data DeregisterParticipationEventMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *DeregisterParticipationEventMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in DeregisterParticipationEventMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in DeregisterParticipationEventMethod: required")
	}
	type Plain DeregisterParticipationEventMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = DeregisterParticipationEventMethod(plain)
	return nil
}


type EmitTestEventMethodDataEvent map[string]interface{}

type EmitTestEventMethodData struct {
	// Event corresponds to the JSON schema field "event".
	Event EmitTestEventMethodDataEvent `json:"event" yaml:"event" mapstructure:"event"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *EmitTestEventMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["event"]; !ok || v == nil {
		return fmt.Errorf("field event in EmitTestEventMethodData: required")
	}
	type Plain EmitTestEventMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = EmitTestEventMethodData(plain)
	return nil
}


type EmitTestEventMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data EmitTestEventMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *EmitTestEventMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in EmitTestEventMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in EmitTestEventMethod: required")
	}
	type Plain EmitTestEventMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = EmitTestEventMethod(plain)
	return nil
}


type FaucetMethodData struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type GetMilestoneByIndexMethodData struct {
	// Index corresponds to the JSON schema field "index".
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`
}

type BuildNftOutputDataUnlockConditionsElem map[string]interface{}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IGossipMetrics) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["droppedPackets"]; !ok || v == nil {
		return fmt.Errorf("field droppedPackets in IGossipMetrics: required")
	}
	if v, ok := raw["knownBlocks"]; !ok || v == nil {
		return fmt.Errorf("field knownBlocks in IGossipMetrics: required")
	}
	if v, ok := raw["newBlocks"]; !ok || v == nil {
		return fmt.Errorf("field newBlocks in IGossipMetrics: required")
	}
	if v, ok := raw["receivedBlockRequests"]; !ok || v == nil {
		return fmt.Errorf("field receivedBlockRequests in IGossipMetrics: required")
	}
	if v, ok := raw["receivedBlocks"]; !ok || v == nil {
		return fmt.Errorf("field receivedBlocks in IGossipMetrics: required")
	}
	if v, ok := raw["receivedHeartbeats"]; !ok || v == nil {
		return fmt.Errorf("field receivedHeartbeats in IGossipMetrics: required")
	}
	if v, ok := raw["receivedMilestoneRequests"]; !ok || v == nil {
		return fmt.Errorf("field receivedMilestoneRequests in IGossipMetrics: required")
	}
	if v, ok := raw["sentBlockRequests"]; !ok || v == nil {
		return fmt.Errorf("field sentBlockRequests in IGossipMetrics: required")
	}
	if v, ok := raw["sentBlocks"]; !ok || v == nil {
		return fmt.Errorf("field sentBlocks in IGossipMetrics: required")
	}
	if v, ok := raw["sentHeartbeats"]; !ok || v == nil {
		return fmt.Errorf("field sentHeartbeats in IGossipMetrics: required")
	}
	if v, ok := raw["sentMilestoneRequests"]; !ok || v == nil {
		return fmt.Errorf("field sentMilestoneRequests in IGossipMetrics: required")
	}
	type Plain IGossipMetrics
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IGossipMetrics(plain)
	return nil
}


type FindBlocksMethodData struct {
	// BlockIds corresponds to the JSON schema field "blockIds".
	BlockIds []string `json:"blockIds" yaml:"blockIds" mapstructure:"blockIds"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindBlocksMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockIds"]; !ok || v == nil {
		return fmt.Errorf("field blockIds in FindBlocksMethodData: required")
	}
	type Plain FindBlocksMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindBlocksMethodData(plain)
	return nil
}


type FindBlocksMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FindBlocksMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindBlocksMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FindBlocksMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FindBlocksMethod: required")
	}
	type Plain FindBlocksMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindBlocksMethod(plain)
	return nil
}


type FindInputsMethodData struct {
	// Addresses corresponds to the JSON schema field "addresses".
	Addresses []string `json:"addresses" yaml:"addresses" mapstructure:"addresses"`

	// Amount corresponds to the JSON schema field "amount".
	Amount float64 `json:"amount" yaml:"amount" mapstructure:"amount"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindInputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["addresses"]; !ok || v == nil {
		return fmt.Errorf("field addresses in FindInputsMethodData: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in FindInputsMethodData: required")
	}
	type Plain FindInputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindInputsMethodData(plain)
	return nil
}


type FindInputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FindInputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindInputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FindInputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FindInputsMethod: required")
	}
	type Plain FindInputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindInputsMethod(plain)
	return nil
}


type FindOutputsMethodData struct {
	// Addresses corresponds to the JSON schema field "addresses".
	Addresses []string `json:"addresses" yaml:"addresses" mapstructure:"addresses"`

	// OutputIds corresponds to the JSON schema field "outputIds".
	OutputIds []string `json:"outputIds" yaml:"outputIds" mapstructure:"outputIds"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindOutputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["addresses"]; !ok || v == nil {
		return fmt.Errorf("field addresses in FindOutputsMethodData: required")
	}
	if v, ok := raw["outputIds"]; !ok || v == nil {
		return fmt.Errorf("field outputIds in FindOutputsMethodData: required")
	}
	type Plain FindOutputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindOutputsMethodData(plain)
	return nil
}


type FindOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FindOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FindOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FindOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FindOutputsMethod: required")
	}
	type Plain FindOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FindOutputsMethod(plain)
	return nil
}


type FoundryOutputIdMethodData struct {
	// FoundryId corresponds to the JSON schema field "foundryId".
	FoundryId string `json:"foundryId" yaml:"foundryId" mapstructure:"foundryId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundryOutputIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["foundryId"]; !ok || v == nil {
		return fmt.Errorf("field foundryId in FoundryOutputIdMethodData: required")
	}
	type Plain FoundryOutputIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FoundryOutputIdMethodData(plain)
	return nil
}


type FoundryOutputIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FoundryOutputIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundryOutputIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FoundryOutputIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FoundryOutputIdMethod: required")
	}
	type Plain FoundryOutputIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FoundryOutputIdMethod(plain)
	return nil
}


type FoundryOutputIdsMethodDataQueryParametersElem interface{}

type FoundryOutputIdsMethodData struct {
	// QueryParameters corresponds to the JSON schema field "queryParameters".
	QueryParameters []FoundryOutputIdsMethodDataQueryParametersElem `json:"queryParameters" yaml:"queryParameters" mapstructure:"queryParameters"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundryOutputIdsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["queryParameters"]; !ok || v == nil {
		return fmt.Errorf("field queryParameters in FoundryOutputIdsMethodData: required")
	}
	type Plain FoundryOutputIdsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FoundryOutputIdsMethodData(plain)
	return nil
}


type FoundryOutputIdsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data FoundryOutputIdsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundryOutputIdsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in FoundryOutputIdsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in FoundryOutputIdsMethod: required")
	}
	type Plain FoundryOutputIdsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = FoundryOutputIdsMethod(plain)
	return nil
}




type GenerateEd25519AddressesMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options IGenerateAddressesOptions `json:"options" yaml:"options" mapstructure:"options"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GenerateEd25519AddressesMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["options"]; !ok || v == nil {
		return fmt.Errorf("field options in GenerateEd25519AddressesMethodData: required")
	}
	type Plain GenerateEd25519AddressesMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GenerateEd25519AddressesMethodData(plain)
	return nil
}


type GenerateEd25519AddressesMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GenerateEd25519AddressesMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GenerateEd25519AddressesMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GenerateEd25519AddressesMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GenerateEd25519AddressesMethod: required")
	}
	type Plain GenerateEd25519AddressesMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GenerateEd25519AddressesMethod(plain)
	return nil
}


type GenerateEvmAddressesMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options IGenerateAddressesOptions `json:"options" yaml:"options" mapstructure:"options"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GenerateEvmAddressesMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["options"]; !ok || v == nil {
		return fmt.Errorf("field options in GenerateEvmAddressesMethodData: required")
	}
	type Plain GenerateEvmAddressesMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GenerateEvmAddressesMethodData(plain)
	return nil
}


type GenerateEvmAddressesMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GenerateEvmAddressesMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GenerateEvmAddressesMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GenerateEvmAddressesMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GenerateEvmAddressesMethod: required")
	}
	type Plain GenerateEvmAddressesMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GenerateEvmAddressesMethod(plain)
	return nil
}





type GetBalanceMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBalanceMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBalanceMethod: required")
	}
	type Plain GetBalanceMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBalanceMethod(plain)
	return nil
}


type GetBasicOutputIdsMethodDataQueryParametersElem interface{}

type GetBasicOutputIdsMethodData struct {
	// QueryParameters corresponds to the JSON schema field "queryParameters".
	QueryParameters []GetBasicOutputIdsMethodDataQueryParametersElem `json:"queryParameters" yaml:"queryParameters" mapstructure:"queryParameters"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBasicOutputIdsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["queryParameters"]; !ok || v == nil {
		return fmt.Errorf("field queryParameters in GetBasicOutputIdsMethodData: required")
	}
	type Plain GetBasicOutputIdsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBasicOutputIdsMethodData(plain)
	return nil
}


type GetBasicOutputIdsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetBasicOutputIdsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBasicOutputIdsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetBasicOutputIdsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBasicOutputIdsMethod: required")
	}
	type Plain GetBasicOutputIdsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBasicOutputIdsMethod(plain)
	return nil
}


type GetBech32HrpMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBech32HrpMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBech32HrpMethod: required")
	}
	type Plain GetBech32HrpMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBech32HrpMethod(plain)
	return nil
}


type GetBlockMetadataMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockMetadataMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in GetBlockMetadataMethodData: required")
	}
	type Plain GetBlockMetadataMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockMetadataMethodData(plain)
	return nil
}


type GetBlockMetadataMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetBlockMetadataMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockMetadataMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetBlockMetadataMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBlockMetadataMethod: required")
	}
	type Plain GetBlockMetadataMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockMetadataMethod(plain)
	return nil
}


type GetBlockMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in GetBlockMethodData: required")
	}
	type Plain GetBlockMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockMethodData(plain)
	return nil
}


type GetBlockMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetBlockMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetBlockMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBlockMethod: required")
	}
	type Plain GetBlockMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockMethod(plain)
	return nil
}


type GetBlockRawMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockRawMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["blockId"]; !ok || v == nil {
		return fmt.Errorf("field blockId in GetBlockRawMethodData: required")
	}
	type Plain GetBlockRawMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockRawMethodData(plain)
	return nil
}


type GetBlockRawMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetBlockRawMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetBlockRawMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetBlockRawMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetBlockRawMethod: required")
	}
	type Plain GetBlockRawMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetBlockRawMethod(plain)
	return nil
}


type GetFallbackToLocalPowMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFallbackToLocalPowMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetFallbackToLocalPowMethod: required")
	}
	type Plain GetFallbackToLocalPowMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetFallbackToLocalPowMethod(plain)
	return nil
}


type GetFoundryOutputMethodData struct {
	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFoundryOutputMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in GetFoundryOutputMethodData: required")
	}
	type Plain GetFoundryOutputMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetFoundryOutputMethodData(plain)
	return nil
}


type GetFoundryOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetFoundryOutputMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFoundryOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetFoundryOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetFoundryOutputMethod: required")
	}
	type Plain GetFoundryOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetFoundryOutputMethod(plain)
	return nil
}


type GetHealthMethodData struct {
	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetHealthMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in GetHealthMethodData: required")
	}
	type Plain GetHealthMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetHealthMethodData(plain)
	return nil
}


type GetHealthMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetHealthMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetHealthMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetHealthMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetHealthMethod: required")
	}
	type Plain GetHealthMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetHealthMethod(plain)
	return nil
}


type GetIncludedBlockMetadataMethodData struct {
	// TransactionId corresponds to the JSON schema field "transactionId".
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncludedBlockMetadataMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in GetIncludedBlockMetadataMethodData: required")
	}
	type Plain GetIncludedBlockMetadataMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncludedBlockMetadataMethodData(plain)
	return nil
}


type GetIncludedBlockMetadataMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetIncludedBlockMetadataMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncludedBlockMetadataMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetIncludedBlockMetadataMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetIncludedBlockMetadataMethod: required")
	}
	type Plain GetIncludedBlockMetadataMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncludedBlockMetadataMethod(plain)
	return nil
}


type GetIncludedBlockMethodData struct {
	// TransactionId corresponds to the JSON schema field "transactionId".
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncludedBlockMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in GetIncludedBlockMethodData: required")
	}
	type Plain GetIncludedBlockMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncludedBlockMethodData(plain)
	return nil
}


type GetIncludedBlockMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetIncludedBlockMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncludedBlockMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetIncludedBlockMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetIncludedBlockMethod: required")
	}
	type Plain GetIncludedBlockMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncludedBlockMethod(plain)
	return nil
}


type GetIncomingTransactionMethodData struct {
	// TransactionId corresponds to the JSON schema field "transactionId".
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncomingTransactionMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in GetIncomingTransactionMethodData: required")
	}
	type Plain GetIncomingTransactionMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncomingTransactionMethodData(plain)
	return nil
}


type GetIncomingTransactionMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetIncomingTransactionMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetIncomingTransactionMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetIncomingTransactionMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetIncomingTransactionMethod: required")
	}
	type Plain GetIncomingTransactionMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetIncomingTransactionMethod(plain)
	return nil
}


type GetInfoMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetInfoMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetInfoMethod: required")
	}
	type Plain GetInfoMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetInfoMethod(plain)
	return nil
}


type GetLocalPowMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLocalPowMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetLocalPowMethod: required")
	}
	type Plain GetLocalPowMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetLocalPowMethod(plain)
	return nil
}


type GetMilestoneByIdMethodData struct {
	// MilestoneId corresponds to the JSON schema field "milestoneId".
	MilestoneId string `json:"milestoneId" yaml:"milestoneId" mapstructure:"milestoneId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetMilestoneByIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["milestoneId"]; !ok || v == nil {
		return fmt.Errorf("field milestoneId in GetMilestoneByIdMethodData: required")
	}
	type Plain GetMilestoneByIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetMilestoneByIdMethodData(plain)
	return nil
}


type GetMilestoneByIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetMilestoneByIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetMilestoneByIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetMilestoneByIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetMilestoneByIdMethod: required")
	}
	type Plain GetMilestoneByIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetMilestoneByIdMethod(plain)
	return nil
}


// An Address of the Account
type AccountAddress struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Internal corresponds to the JSON schema field "internal".
	Internal bool `json:"internal" yaml:"internal" mapstructure:"internal"`

	// KeyIndex corresponds to the JSON schema field "keyIndex".
	KeyIndex float64 `json:"keyIndex" yaml:"keyIndex" mapstructure:"keyIndex"`

	// Used corresponds to the JSON schema field "used".
	Used bool `json:"used" yaml:"used" mapstructure:"used"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetMilestoneByIndexMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in GetMilestoneByIndexMethodData: required")
	}
	type Plain GetMilestoneByIndexMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetMilestoneByIndexMethodData(plain)
	return nil
}


type GetMilestoneByIndexMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetMilestoneByIndexMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetMilestoneByIndexMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetMilestoneByIndexMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetMilestoneByIndexMethod: required")
	}
	type Plain GetMilestoneByIndexMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetMilestoneByIndexMethod(plain)
	return nil
}


type GetMinPowScoreMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetMinPowScoreMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetMinPowScoreMethod: required")
	}
	type Plain GetMinPowScoreMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetMinPowScoreMethod(plain)
	return nil
}


type GetNetworkIdMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetNetworkIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetNetworkIdMethod: required")
	}
	type Plain GetNetworkIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetNetworkIdMethod(plain)
	return nil
}


type GetNetworkInfoMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetNetworkInfoMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetNetworkInfoMethod: required")
	}
	type Plain GetNetworkInfoMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetNetworkInfoMethod(plain)
	return nil
}


type GetNodeInfoMethodData struct {
	// Auth corresponds to the JSON schema field "auth".
	Auth *IAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetNodeInfoMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in GetNodeInfoMethodData: required")
	}
	type Plain GetNodeInfoMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetNodeInfoMethodData(plain)
	return nil
}


type GetNodeInfoMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetNodeInfoMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetNodeInfoMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetNodeInfoMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetNodeInfoMethod: required")
	}
	type Plain GetNodeInfoMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetNodeInfoMethod(plain)
	return nil
}


type GetNodeMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetNodeMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetNodeMethod: required")
	}
	type Plain GetNodeMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetNodeMethod(plain)
	return nil
}


type GetOutputMethodData struct {
	// OutputId corresponds to the JSON schema field "outputId".
	OutputId string `json:"outputId" yaml:"outputId" mapstructure:"outputId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputId"]; !ok || v == nil {
		return fmt.Errorf("field outputId in GetOutputMethodData: required")
	}
	type Plain GetOutputMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputMethodData(plain)
	return nil
}


type GetOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetOutputMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetOutputMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetOutputMethod: required")
	}
	type Plain GetOutputMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputMethod(plain)
	return nil
}


type GetOutputsIgnoreErrorsMethodData struct {
	// OutputIds corresponds to the JSON schema field "outputIds".
	OutputIds []string `json:"outputIds" yaml:"outputIds" mapstructure:"outputIds"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputsIgnoreErrorsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputIds"]; !ok || v == nil {
		return fmt.Errorf("field outputIds in GetOutputsIgnoreErrorsMethodData: required")
	}
	type Plain GetOutputsIgnoreErrorsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputsIgnoreErrorsMethodData(plain)
	return nil
}


type GetOutputsIgnoreErrorsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetOutputsIgnoreErrorsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputsIgnoreErrorsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetOutputsIgnoreErrorsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetOutputsIgnoreErrorsMethod: required")
	}
	type Plain GetOutputsIgnoreErrorsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputsIgnoreErrorsMethod(plain)
	return nil
}


type GetOutputsMethodData struct {
	// OutputIds corresponds to the JSON schema field "outputIds".
	OutputIds []string `json:"outputIds" yaml:"outputIds" mapstructure:"outputIds"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["outputIds"]; !ok || v == nil {
		return fmt.Errorf("field outputIds in GetOutputsMethodData: required")
	}
	type Plain GetOutputsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputsMethodData(plain)
	return nil
}


type GetOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetOutputsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetOutputsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetOutputsMethod: required")
	}
	type Plain GetOutputsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetOutputsMethod(plain)
	return nil
}


type GetParticipationEventIdsMethodData struct {
	// EventType corresponds to the JSON schema field "eventType".
	EventType *ParticipationEventType `json:"eventType,omitempty" yaml:"eventType,omitempty" mapstructure:"eventType,omitempty"`

	// Node corresponds to the JSON schema field "node".
	Node INode `json:"node" yaml:"node" mapstructure:"node"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventIdsMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node in GetParticipationEventIdsMethodData: required")
	}
	type Plain GetParticipationEventIdsMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventIdsMethodData(plain)
	return nil
}


type GetParticipationEventIdsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetParticipationEventIdsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventIdsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetParticipationEventIdsMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetParticipationEventIdsMethod: required")
	}
	type Plain GetParticipationEventIdsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventIdsMethod(plain)
	return nil
}


type GetParticipationEventMethodData struct {
	// EventId corresponds to the JSON schema field "eventId".
	EventId ParticipationEventId `json:"eventId" yaml:"eventId" mapstructure:"eventId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in GetParticipationEventMethodData: required")
	}
	type Plain GetParticipationEventMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventMethodData(plain)
	return nil
}


type GetParticipationEventMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetParticipationEventMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetParticipationEventMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetParticipationEventMethod: required")
	}
	type Plain GetParticipationEventMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventMethod(plain)
	return nil
}


type GetParticipationEventStatusMethodData struct {
	// EventId corresponds to the JSON schema field "eventId".
	EventId ParticipationEventId `json:"eventId" yaml:"eventId" mapstructure:"eventId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventStatusMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in GetParticipationEventStatusMethodData: required")
	}
	type Plain GetParticipationEventStatusMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventStatusMethodData(plain)
	return nil
}


type GetParticipationEventStatusMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetParticipationEventStatusMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventStatusMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetParticipationEventStatusMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetParticipationEventStatusMethod: required")
	}
	type Plain GetParticipationEventStatusMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventStatusMethod(plain)
	return nil
}


type GetParticipationEventsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationEventsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetParticipationEventsMethod: required")
	}
	type Plain GetParticipationEventsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationEventsMethod(plain)
	return nil
}


type GetParticipationOverviewMethodData struct {
	// EventIds corresponds to the JSON schema field "eventIds".
	EventIds []ParticipationEventId `json:"eventIds,omitempty" yaml:"eventIds,omitempty" mapstructure:"eventIds,omitempty"`
}

type GetParticipationOverviewMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetParticipationOverviewMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetParticipationOverviewMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetParticipationOverviewMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetParticipationOverviewMethod: required")
	}
	type Plain GetParticipationOverviewMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetParticipationOverviewMethod(plain)
	return nil
}


type GetPeersMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPeersMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetPeersMethod: required")
	}
	type Plain GetPeersMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetPeersMethod(plain)
	return nil
}


type GetProtocolParametersMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetProtocolParametersMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetProtocolParametersMethod: required")
	}
	type Plain GetProtocolParametersMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetProtocolParametersMethod(plain)
	return nil
}


type GetReceiptsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetReceiptsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetReceiptsMethod: required")
	}
	type Plain GetReceiptsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetReceiptsMethod(plain)
	return nil
}


type GetReceiptsMigratedAtMethodData struct {
	// MilestoneIndex corresponds to the JSON schema field "milestoneIndex".
	MilestoneIndex float64 `json:"milestoneIndex" yaml:"milestoneIndex" mapstructure:"milestoneIndex"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetReceiptsMigratedAtMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["milestoneIndex"]; !ok || v == nil {
		return fmt.Errorf("field milestoneIndex in GetReceiptsMigratedAtMethodData: required")
	}
	type Plain GetReceiptsMigratedAtMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetReceiptsMigratedAtMethodData(plain)
	return nil
}


type GetReceiptsMigratedAtMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetReceiptsMigratedAtMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetReceiptsMigratedAtMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetReceiptsMigratedAtMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetReceiptsMigratedAtMethod: required")
	}
	type Plain GetReceiptsMigratedAtMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetReceiptsMigratedAtMethod(plain)
	return nil
}


type GetTipsIntervalMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTipsIntervalMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetTipsIntervalMethod: required")
	}
	type Plain GetTipsIntervalMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetTipsIntervalMethod(plain)
	return nil
}


type GetTipsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTipsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetTipsMethod: required")
	}
	type Plain GetTipsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetTipsMethod(plain)
	return nil
}


type GetTransactionMethodData struct {
	// TransactionId corresponds to the JSON schema field "transactionId".
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTransactionMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["transactionId"]; !ok || v == nil {
		return fmt.Errorf("field transactionId in GetTransactionMethodData: required")
	}
	type Plain GetTransactionMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetTransactionMethodData(plain)
	return nil
}


type GetTransactionMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetTransactionMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTransactionMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetTransactionMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetTransactionMethod: required")
	}
	type Plain GetTransactionMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetTransactionMethod(plain)
	return nil
}


type GetTreasuryMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTreasuryMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetTreasuryMethod: required")
	}
	type Plain GetTreasuryMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetTreasuryMethod(plain)
	return nil
}


type GetUtxoChangesByIdMethodData struct {
	// MilestoneId corresponds to the JSON schema field "milestoneId".
	MilestoneId string `json:"milestoneId" yaml:"milestoneId" mapstructure:"milestoneId"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUtxoChangesByIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["milestoneId"]; !ok || v == nil {
		return fmt.Errorf("field milestoneId in GetUtxoChangesByIdMethodData: required")
	}
	type Plain GetUtxoChangesByIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetUtxoChangesByIdMethodData(plain)
	return nil
}


type GetUtxoChangesByIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetUtxoChangesByIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUtxoChangesByIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetUtxoChangesByIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetUtxoChangesByIdMethod: required")
	}
	type Plain GetUtxoChangesByIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetUtxoChangesByIdMethod(plain)
	return nil
}


type GetUtxoChangesByIndexMethodData struct {
	// Index corresponds to the JSON schema field "index".
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUtxoChangesByIndexMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in GetUtxoChangesByIndexMethodData: required")
	}
	type Plain GetUtxoChangesByIndexMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetUtxoChangesByIndexMethodData(plain)
	return nil
}


type GetUtxoChangesByIndexMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data GetUtxoChangesByIndexMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUtxoChangesByIndexMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in GetUtxoChangesByIndexMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in GetUtxoChangesByIndexMethod: required")
	}
	type Plain GetUtxoChangesByIndexMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = GetUtxoChangesByIndexMethod(plain)
	return nil
}


type HashTransactionEssenceMethodDataEssence map[string]interface{}

type HashTransactionEssenceMethodData struct {
	// Essence corresponds to the JSON schema field "essence".
	Essence HashTransactionEssenceMethodDataEssence `json:"essence" yaml:"essence" mapstructure:"essence"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HashTransactionEssenceMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["essence"]; !ok || v == nil {
		return fmt.Errorf("field essence in HashTransactionEssenceMethodData: required")
	}
	type Plain HashTransactionEssenceMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HashTransactionEssenceMethodData(plain)
	return nil
}


type HashTransactionEssenceMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data HashTransactionEssenceMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HashTransactionEssenceMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in HashTransactionEssenceMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in HashTransactionEssenceMethod: required")
	}
	type Plain HashTransactionEssenceMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HashTransactionEssenceMethod(plain)
	return nil
}


type HexPublicKeyToBech32AddressMethodData struct {
	// Bech32Hrp corresponds to the JSON schema field "bech32Hrp".
	Bech32Hrp string `json:"bech32Hrp,omitempty" yaml:"bech32Hrp,omitempty" mapstructure:"bech32Hrp,omitempty"`

	// Hex corresponds to the JSON schema field "hex".
	Hex string `json:"hex" yaml:"hex" mapstructure:"hex"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HexPublicKeyToBech32AddressMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["hex"]; !ok || v == nil {
		return fmt.Errorf("field hex in HexPublicKeyToBech32AddressMethodData: required")
	}
	type Plain HexPublicKeyToBech32AddressMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HexPublicKeyToBech32AddressMethodData(plain)
	return nil
}


type HexPublicKeyToBech32AddressMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data HexPublicKeyToBech32AddressMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HexPublicKeyToBech32AddressMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in HexPublicKeyToBech32AddressMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in HexPublicKeyToBech32AddressMethod: required")
	}
	type Plain HexPublicKeyToBech32AddressMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HexPublicKeyToBech32AddressMethod(plain)
	return nil
}


type HexToBech32MethodData struct {
	// Bech32Hrp corresponds to the JSON schema field "bech32Hrp".
	Bech32Hrp string `json:"bech32Hrp,omitempty" yaml:"bech32Hrp,omitempty" mapstructure:"bech32Hrp,omitempty"`

	// Hex corresponds to the JSON schema field "hex".
	Hex string `json:"hex" yaml:"hex" mapstructure:"hex"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HexToBech32MethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["hex"]; !ok || v == nil {
		return fmt.Errorf("field hex in HexToBech32MethodData: required")
	}
	type Plain HexToBech32MethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HexToBech32MethodData(plain)
	return nil
}


type HexToBech32Method struct {
	// Data corresponds to the JSON schema field "data".
	Data HexToBech32MethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *HexToBech32Method) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in HexToBech32Method: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in HexToBech32Method: required")
	}
	type Plain HexToBech32Method
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = HexToBech32Method(plain)
	return nil
}


type IncomingTransactionsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IncomingTransactionsMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in IncomingTransactionsMethod: required")
	}
	type Plain IncomingTransactionsMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IncomingTransactionsMethod(plain)
	return nil
}


type IsAddressValidMethodData struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IsAddressValidMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in IsAddressValidMethodData: required")
	}
	type Plain IsAddressValidMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IsAddressValidMethodData(plain)
	return nil
}


type IsAddressValidMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data IsAddressValidMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


// UnmarshalJSON implements json.Unmarshaler.
func (j *IsAddressValidMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in IsAddressValidMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in IsAddressValidMethod: required")
	}
	type Plain IsAddressValidMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = IsAddressValidMethod(plain)
	return nil
}





// UnmarshalJSON implements json.Unmarshaler.
func (j *MnemonicToHexSeedMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in MnemonicToHexSeedMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in MnemonicToHexSeedMethod: required")
	}
	type Plain MnemonicToHexSeedMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MnemonicToHexSeedMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MnemonicToHexSeedMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["mnemonic"]; !ok || v == nil {
		return fmt.Errorf("field mnemonic in MnemonicToHexSeedMethodData: required")
	}
	type Plain MnemonicToHexSeedMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MnemonicToHexSeedMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MinimumRequiredStorageDepositMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in MinimumRequiredStorageDepositMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in MinimumRequiredStorageDepositMethod: required")
	}
	type Plain MinimumRequiredStorageDepositMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MinimumRequiredStorageDepositMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MilestoneIdMethodDataPayloadSignaturesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["publicKey"]; !ok || v == nil {
		return fmt.Errorf("field publicKey in MilestoneIdMethodDataPayloadSignaturesElem: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in MilestoneIdMethodDataPayloadSignaturesElem: required")
	}
	type Plain MilestoneIdMethodDataPayloadSignaturesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MilestoneIdMethodDataPayloadSignaturesElem(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MinimumRequiredStorageDepositMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output in MinimumRequiredStorageDepositMethodData: required")
	}
	type Plain MinimumRequiredStorageDepositMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MinimumRequiredStorageDepositMethodData(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MilestoneIdMethodDataPayload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["appliedMerkleRoot"]; !ok || v == nil {
		return fmt.Errorf("field appliedMerkleRoot in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["inclusionMerkleRoot"]; !ok || v == nil {
		return fmt.Errorf("field inclusionMerkleRoot in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["parents"]; !ok || v == nil {
		return fmt.Errorf("field parents in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["previousMilestoneId"]; !ok || v == nil {
		return fmt.Errorf("field previousMilestoneId in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["protocolVersion"]; !ok || v == nil {
		return fmt.Errorf("field protocolVersion in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["signatures"]; !ok || v == nil {
		return fmt.Errorf("field signatures in MilestoneIdMethodDataPayload: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp in MilestoneIdMethodDataPayload: required")
	}
	type Plain MilestoneIdMethodDataPayload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MilestoneIdMethodDataPayload(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MilestoneIdMethod) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in MilestoneIdMethod: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in MilestoneIdMethod: required")
	}
	type Plain MilestoneIdMethod
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MilestoneIdMethod(plain)
	return nil
}



// UnmarshalJSON implements json.Unmarshaler.
func (j *MilestoneIdMethodData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil { return err }
	if v, ok := raw["payload"]; !ok || v == nil {
		return fmt.Errorf("field payload in MilestoneIdMethodData: required")
	}
	type Plain MilestoneIdMethodData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil { return err }
	*j = MilestoneIdMethodData(plain)
	return nil
}


type PrepareMintNftsMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []MintNftParams `json:"params" yaml:"params" mapstructure:"params"`
}

type MilestoneIdMethodData struct {
	// Payload corresponds to the JSON schema field "payload".
	Payload MilestoneIdMethodDataPayload `json:"payload" yaml:"payload" mapstructure:"payload"`
}

type MinimumRequiredStorageDepositMethodDataOutput map[string]interface{}

type MinimumRequiredStorageDepositMethodData struct {
	// Output corresponds to the JSON schema field "output".
	Output MinimumRequiredStorageDepositMethodDataOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type MilestoneIdMethodDataPayload struct {
	// The Merkle tree hash of all blocks applied by this milestone.
	AppliedMerkleRoot HexEncodedString `json:"appliedMerkleRoot" yaml:"appliedMerkleRoot" mapstructure:"appliedMerkleRoot"`

	// The Merkle tree hash of all blocks confirmed by this milestone.
	InclusionMerkleRoot HexEncodedString `json:"inclusionMerkleRoot" yaml:"inclusionMerkleRoot" mapstructure:"inclusionMerkleRoot"`

	// The index name.
	Index float64 `json:"index" yaml:"index" mapstructure:"index"`

	// The metadata.
	Metadata *HexEncodedString `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The milestone options.
	Options []MilestoneIdMethodDataPayloadOptionsElem `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// The parents where this milestone attaches to.
	Parents []HexEncodedString `json:"parents" yaml:"parents" mapstructure:"parents"`

	// The id of the previous milestone.
	PreviousMilestoneId HexEncodedString `json:"previousMilestoneId" yaml:"previousMilestoneId" mapstructure:"previousMilestoneId"`

	// The protocol version.
	ProtocolVersion float64 `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`

	// The signatures.
	Signatures []MilestoneIdMethodDataPayloadSignaturesElem `json:"signatures" yaml:"signatures" mapstructure:"signatures"`

	// The timestamp of the milestone.
	Timestamp float64 `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

type MinimumRequiredStorageDepositMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data MinimumRequiredStorageDepositMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Ed25519Signature signature.
type MilestoneIdMethodDataPayloadSignaturesElem struct {
	// The public key.
	PublicKey HexEncodedString `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// The signature.
	Signature HexEncodedString `json:"signature" yaml:"signature" mapstructure:"signature"`
}

type MnemonicToHexSeedMethodData struct {
	// Mnemonic corresponds to the JSON schema field "mnemonic".
	Mnemonic string `json:"mnemonic" yaml:"mnemonic" mapstructure:"mnemonic"`
}

type MilestoneIdMethodDataPayloadOptionsElem map[string]interface{}

type MnemonicToHexSeedMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data MnemonicToHexSeedMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type Method interface{}

type NftIdToBech32MethodData struct {
	// Bech32Hrp corresponds to the JSON schema field "bech32Hrp".
	Bech32Hrp string `json:"bech32Hrp,omitempty" yaml:"bech32Hrp,omitempty" mapstructure:"bech32Hrp,omitempty"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`
}

// The output.
type OutputResponseOutput map[string]interface{}

type NftIdToBech32Method struct {
	// Data corresponds to the JSON schema field "data".
	Data NftIdToBech32MethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Details of an output.
type OutputResponse struct {
	// The metadata about the output.
	Metadata IOutputMetadataResponse `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// The output.
	Output OutputResponseOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// Associated account address
type OutputDataAddress map[string]interface{}

// The actual Output
type OutputDataOutput map[string]interface{}

type NftOutputIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data NftOutputIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type OutputId string

type NftOutputIdsMethodDataQueryParametersElem interface{}

type NftOutputIdsMethodData struct {
	// QueryParameters corresponds to the JSON schema field "queryParameters".
	QueryParameters []NftOutputIdsMethodDataQueryParametersElem `json:"queryParameters" yaml:"queryParameters" mapstructure:"queryParameters"`
}

// An output with metadata
type OutputData struct {
	// Associated account address
	Address OutputDataAddress `json:"address" yaml:"address" mapstructure:"address"`

	// BIP32 path
	Chain []Segment `json:"chain,omitempty" yaml:"chain,omitempty" mapstructure:"chain,omitempty"`

	// If an output is spent
	IsSpent bool `json:"isSpent" yaml:"isSpent" mapstructure:"isSpent"`

	// The metadata of the output
	Metadata IOutputMetadataResponse `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Network ID
	NetworkId string `json:"networkId" yaml:"networkId" mapstructure:"networkId"`

	// The actual Output
	Output OutputDataOutput `json:"output" yaml:"output" mapstructure:"output"`

	// The identifier of an Output
	OutputId OutputId `json:"outputId" yaml:"outputId" mapstructure:"outputId"`

	// Remainder
	Remainder bool `json:"remainder" yaml:"remainder" mapstructure:"remainder"`
}

type NftOutputIdsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data NftOutputIdsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// The balance of a native token
type NativeTokenBalance struct {
	// Available corresponds to the JSON schema field "available".
	Available HexEncodedAmount `json:"available" yaml:"available" mapstructure:"available"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata string `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId HexEncodedString `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// Total corresponds to the JSON schema field "total".
	Total HexEncodedAmount `json:"total" yaml:"total" mapstructure:"total"`
}

type OutputsMethodData struct {
	// FilterOptions corresponds to the JSON schema field "filterOptions".
	FilterOptions *FilterOptions `json:"filterOptions,omitempty" yaml:"filterOptions,omitempty" mapstructure:"filterOptions,omitempty"`
}

type OutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data OutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type LedgerInclusionState string

type ParseBech32AddressMethodData struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`
}

const LedgerInclusionStateNoTransaction LedgerInclusionState = "noTransaction"
type ParseBech32AddressMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ParseBech32AddressMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

const LedgerInclusionStateIncluded LedgerInclusionState = "included"
type PendingTransactionsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

const LedgerInclusionStateConflicting LedgerInclusionState = "conflicting"
type PostBlockMethodData struct {
	// Block corresponds to the JSON schema field "block".
	Block Block `json:"block" yaml:"block" mapstructure:"block"`
}

// Defines changing protocol parameters in a milestone.
type NodeInfoProtocolParamsMilestoneOpt struct {
	// The protocol parameters in binary form. Hex-encoded with 0x prefix.
	Params string `json:"params" yaml:"params" mapstructure:"params"`

	// The to be applied protocol version.
	ProtocolVersion float64 `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`

	// The milestone index at which these protocol parameters become active.
	TargetMilestoneIndex float64 `json:"targetMilestoneIndex" yaml:"targetMilestoneIndex" mapstructure:"targetMilestoneIndex"`
}

type PostBlockMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PostBlockMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


type PostBlockPayloadMethodDataPayload map[string]interface{}

type PostBlockPayloadMethodData struct {
	// Payload corresponds to the JSON schema field "payload".
	Payload PostBlockPayloadMethodDataPayload `json:"payload" yaml:"payload" mapstructure:"payload"`
}


type PostBlockPayloadMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PostBlockPayloadMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// The target address of the migrated funds.
type MigratedFundsAddress map[string]interface{}

type PostBlockRawMethodData struct {
	// Block corresponds to the JSON schema field "block".
	Block Block `json:"block" yaml:"block" mapstructure:"block"`
}

// The migrated funds for receipts.
type MigratedFunds struct {
	// The target address of the migrated funds.
	Address MigratedFundsAddress `json:"address" yaml:"address" mapstructure:"address"`

	// The amount of the deposit.
	Deposit string `json:"deposit" yaml:"deposit" mapstructure:"deposit"`

	// The tail transaction hash of the migration bundle.
	TailTransactionHash HexEncodedString `json:"tailTransactionHash" yaml:"tailTransactionHash" mapstructure:"tailTransactionHash"`
}

type PostBlockRawMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PostBlockRawMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type MilestoneId string

type PrepareBurnMethodData struct {
	// Burn corresponds to the JSON schema field "burn".
	Burn Burn `json:"burn" yaml:"burn" mapstructure:"burn"`

	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

type MilestoneReceipt struct {
	// The milestone index.
	MilestoneIndex float64 `json:"milestoneIndex" yaml:"milestoneIndex" mapstructure:"milestoneIndex"`

	// The receipt.
	Receipt ReceiptMilestoneOption `json:"receipt" yaml:"receipt" mapstructure:"receipt"`
}

type PrepareBurnMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareBurnMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Native token options for minting
type MintNativeTokenParams struct {
	// AliasId corresponds to the JSON schema field "aliasId".
	AliasId string `json:"aliasId,omitempty" yaml:"aliasId,omitempty" mapstructure:"aliasId,omitempty"`

	// Hex encoded number
	CirculatingSupply HexEncodedAmount `json:"circulatingSupply" yaml:"circulatingSupply" mapstructure:"circulatingSupply"`

	// Hex encoded bytes
	FoundryMetadata string `json:"foundryMetadata,omitempty" yaml:"foundryMetadata,omitempty" mapstructure:"foundryMetadata,omitempty"`

	// Hex encoded number
	MaximumSupply HexEncodedAmount `json:"maximumSupply" yaml:"maximumSupply" mapstructure:"maximumSupply"`
}

type PrepareConsolidateOutputsMethodData struct {
	// Force corresponds to the JSON schema field "force".
	Force bool `json:"force" yaml:"force" mapstructure:"force"`

	// OutputConsolidationThreshold corresponds to the JSON schema field
	// "outputConsolidationThreshold".
	OutputConsolidationThreshold float64 `json:"outputConsolidationThreshold,omitempty" yaml:"outputConsolidationThreshold,omitempty" mapstructure:"outputConsolidationThreshold,omitempty"`
}

// Nft options for minting
type MintNftParams struct {
	// Bech32 encoded address to which the Nft will be minted. Default will use the
	// first address of the account
	Address string `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	// Hex encoded bytes
	ImmutableMetadata string `json:"immutableMetadata,omitempty" yaml:"immutableMetadata,omitempty" mapstructure:"immutableMetadata,omitempty"`

	// Bech32 encoded issuer address *
	Issuer string `json:"issuer,omitempty" yaml:"issuer,omitempty" mapstructure:"issuer,omitempty"`

	// Hex encoded bytes
	Metadata string `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Bech32 encoded sender address *
	Sender string `json:"sender,omitempty" yaml:"sender,omitempty" mapstructure:"sender,omitempty"`

	// Hex encoded bytes
	Tag string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type PrepareConsolidateOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareConsolidateOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// The result of a minting operation
type MintTokenTransaction struct {
	// The token id of the minted token
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// The transaction which minted the token
	Transaction Transaction `json:"transaction" yaml:"transaction" mapstructure:"transaction"`
}

type PrepareCreateAliasOutputMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params *AliasOutputParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

type PrepareCreateAliasOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareCreateAliasOutputMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}



type PrepareDecreaseNativeTokenSupplyMethodData struct {
	// MeltAmount corresponds to the JSON schema field "meltAmount".
	MeltAmount HexEncodedAmount `json:"meltAmount" yaml:"meltAmount" mapstructure:"meltAmount"`

	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`
}

type NamedParametersTypeofParsePayload struct {
	// Data corresponds to the JSON schema field "data".
	Data interface{} `json:"data" yaml:"data" mapstructure:"data"`
}

type PrepareDecreaseNativeTokenSupplyMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareDecreaseNativeTokenSupplyMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type Network float64

type PrepareDecreaseVotingPowerMethodData struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`
}

type NftOutputBuilderParamsFeaturesElem map[string]interface{}

type PrepareDecreaseVotingPowerMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareDecreaseVotingPowerMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type NftOutputBuilderParamsImmutableFeaturesElem map[string]interface{}

type PrepareIncreaseNativeTokenSupplyMethodData struct {
	// MintAmount corresponds to the JSON schema field "mintAmount".
	MintAmount HexEncodedAmount `json:"mintAmount" yaml:"mintAmount" mapstructure:"mintAmount"`

	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`
}

type NftOutputBuilderParamsUnlockConditionsElem map[string]interface{}

type PrepareIncreaseNativeTokenSupplyMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareIncreaseNativeTokenSupplyMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Options for building an Nft Output
type NftOutputBuilderParams struct {
	// If not provided, minimum storage deposit will be used
	Amount string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Features to be contained by the output.
	Features []NftOutputBuilderParamsFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// ImmutableFeatures corresponds to the JSON schema field "immutableFeatures".
	ImmutableFeatures []NftOutputBuilderParamsImmutableFeaturesElem `json:"immutableFeatures,omitempty" yaml:"immutableFeatures,omitempty" mapstructure:"immutableFeatures,omitempty"`

	// The native tokens to be held by the output.
	NativeTokens []INativeToken `json:"nativeTokens,omitempty" yaml:"nativeTokens,omitempty" mapstructure:"nativeTokens,omitempty"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId HexEncodedString `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// The unlock conditions for the output.
	UnlockConditions []NftOutputBuilderParamsUnlockConditionsElem `json:"unlockConditions" yaml:"unlockConditions" mapstructure:"unlockConditions"`
}

type PrepareIncreaseVotingPowerMethodData struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`
}

// Query parameters for filtering Nft Outputs
type NftQueryParameter interface{}

type PrepareIncreaseVotingPowerMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareIncreaseVotingPowerMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Specifies what outputs should be synced for the address of an nft output.


type PrepareMintNativeTokenMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params MintNativeTokenParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Options for the creation of an output
type OutputParams struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Assets corresponds to the JSON schema field "assets".
	Assets *Assets `json:"assets,omitempty" yaml:"assets,omitempty" mapstructure:"assets,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features *Features `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// RecipientAddress corresponds to the JSON schema field "recipientAddress".
	RecipientAddress string `json:"recipientAddress" yaml:"recipientAddress" mapstructure:"recipientAddress"`

	// StorageDeposit corresponds to the JSON schema field "storageDeposit".
	StorageDeposit *StorageDeposit `json:"storageDeposit,omitempty" yaml:"storageDeposit,omitempty" mapstructure:"storageDeposit,omitempty"`

	// Unlocks corresponds to the JSON schema field "unlocks".
	Unlocks *Unlocks `json:"unlocks,omitempty" yaml:"unlocks,omitempty" mapstructure:"unlocks,omitempty"`
}

type PrepareMintNativeTokenMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareMintNativeTokenMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type OutputsToClaim string

const OutputsToClaimMicroTransactions OutputsToClaim = "MicroTransactions"
type MilestoneIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data MilestoneIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareMintNftsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareMintNftsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type NftOutputIdMethodData struct {
	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`
}

const OutputsToClaimNfts OutputsToClaim = "Nfts"
const OutputsToClaimAmount OutputsToClaim = "Amount"
const OutputsToClaimAll OutputsToClaim = "All"
type ParticipationEventDataPayload interface{}

type ParticipationEventData struct {
	// AdditionalInfo corresponds to the JSON schema field "additionalInfo".
	AdditionalInfo string `json:"additionalInfo" yaml:"additionalInfo" mapstructure:"additionalInfo"`

	// MilestoneIndexCommence corresponds to the JSON schema field
	// "milestoneIndexCommence".
	MilestoneIndexCommence float64 `json:"milestoneIndexCommence" yaml:"milestoneIndexCommence" mapstructure:"milestoneIndexCommence"`

	// MilestoneIndexEnd corresponds to the JSON schema field "milestoneIndexEnd".
	MilestoneIndexEnd float64 `json:"milestoneIndexEnd" yaml:"milestoneIndexEnd" mapstructure:"milestoneIndexEnd"`

	// MilestoneIndexStart corresponds to the JSON schema field "milestoneIndexStart".
	MilestoneIndexStart float64 `json:"milestoneIndexStart" yaml:"milestoneIndexStart" mapstructure:"milestoneIndexStart"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Payload corresponds to the JSON schema field "payload".
	Payload ParticipationEventDataPayload `json:"payload" yaml:"payload" mapstructure:"payload"`
}

// Placeholder secret manager that can't do anything.
type PlaceholderSecretManager string

type ParticipationEventId string

type ParticipationOverview struct {
	// Participations corresponds to the JSON schema field "participations".
	Participations Participations `json:"participations" yaml:"participations" mapstructure:"participations"`
}

type ParticipationEvent struct {
	// Data corresponds to the JSON schema field "data".
	Data ParticipationEventData `json:"data" yaml:"data" mapstructure:"data"`

	// Id corresponds to the JSON schema field "id".
	Id ParticipationEventId `json:"id" yaml:"id" mapstructure:"id"`
}

type Participations map[string]map[string]TrackedParticipationOverview

const OutputsToClaimNativeTokens OutputsToClaim = "NativeTokens"
type ParticipationEventWithNodes struct {
	// Data corresponds to the JSON schema field "data".
	Data ParticipationEventData `json:"data" yaml:"data" mapstructure:"data"`

	// Id corresponds to the JSON schema field "id".
	Id ParticipationEventId `json:"id" yaml:"id" mapstructure:"id"`

	// Nodes corresponds to the JSON schema field "nodes".
	Nodes []INode `json:"nodes" yaml:"nodes" mapstructure:"nodes"`
}

type ParticipationEventMap map[string]ParticipationEventWithNodes

type ParticipationEventPayload interface{}

type ParticipationEventRegistrationOptions struct {
	// EventsToIgnore corresponds to the JSON schema field "eventsToIgnore".
	EventsToIgnore []ParticipationEventId `json:"eventsToIgnore,omitempty" yaml:"eventsToIgnore,omitempty" mapstructure:"eventsToIgnore,omitempty"`

	// EventsToRegister corresponds to the JSON schema field "eventsToRegister".
	EventsToRegister []ParticipationEventId `json:"eventsToRegister,omitempty" yaml:"eventsToRegister,omitempty" mapstructure:"eventsToRegister,omitempty"`

	// Node corresponds to the JSON schema field "node".
	Node INode `json:"node" yaml:"node" mapstructure:"node"`
}

type ParticipationEventType float64

type ParticipationEventStatus struct {
	// Checksum corresponds to the JSON schema field "checksum".
	Checksum string `json:"checksum" yaml:"checksum" mapstructure:"checksum"`

	// MilestoneIndex corresponds to the JSON schema field "milestoneIndex".
	MilestoneIndex float64 `json:"milestoneIndex" yaml:"milestoneIndex" mapstructure:"milestoneIndex"`

	// Questions corresponds to the JSON schema field "questions".
	Questions []QuestionStatus `json:"questions,omitempty" yaml:"questions,omitempty" mapstructure:"questions,omitempty"`

	// Status corresponds to the JSON schema field "status".
	Status EventStatus `json:"status" yaml:"status" mapstructure:"status"`
}

type PrepareOutputMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareOutputMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareOutputMethodData struct {
	// Params corresponds to the JSON schema field "params".
	Params OutputParams `json:"params" yaml:"params" mapstructure:"params"`

	// TransactionOptions corresponds to the JSON schema field "transactionOptions".
	TransactionOptions *TransactionOptions `json:"transactionOptions,omitempty" yaml:"transactionOptions,omitempty" mapstructure:"transactionOptions,omitempty"`
}

type PrepareSendAmountMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareSendAmountMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareSendAmountMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []SendAmountParams `json:"params" yaml:"params" mapstructure:"params"`
}

type PrepareSendNativeTokensMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareSendNativeTokensMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareSendNativeTokensMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []SendNativeTokensParams `json:"params" yaml:"params" mapstructure:"params"`
}

type PrepareSendNftMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareSendNftMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareSendNftMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []SendNftParams `json:"params" yaml:"params" mapstructure:"params"`
}

type PrepareStopParticipatingMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareStopParticipatingMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareStopParticipatingMethodData struct {
	// EventId corresponds to the JSON schema field "eventId".
	EventId ParticipationEventId `json:"eventId" yaml:"eventId" mapstructure:"eventId"`
}

type PrepareTransactionMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareTransactionMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareTransactionMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *IBuildBlockOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// SecretManager corresponds to the JSON schema field "secretManager".
	SecretManager PrepareTransactionMethodDataSecretManager `json:"secretManager,omitempty" yaml:"secretManager,omitempty" mapstructure:"secretManager,omitempty"`
}

type PrepareTransactionMethodDataSecretManager interface{}

type PrepareVoteMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PrepareVoteMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PrepareVoteMethodData struct {
	// Answers corresponds to the JSON schema field "answers".
	Answers []float64 `json:"answers,omitempty" yaml:"answers,omitempty" mapstructure:"answers,omitempty"`

	// EventId corresponds to the JSON schema field "eventId".
	EventId *ParticipationEventId `json:"eventId,omitempty" yaml:"eventId,omitempty" mapstructure:"eventId,omitempty"`
}

type PreparedMintTokenTransaction map[string]interface{}

// The result of preparing a minting operation
type PreparedMintTokenTransactionData struct {
	// The token id of the minted token
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// The prepared transaction which will mint the token
	Transaction PreparedTransactionData `json:"transaction" yaml:"transaction" mapstructure:"transaction"`
}

// PreparedTransaction` is a class that represents prepared transaction data, which
// is useful for offline signing. It contains the prepared transaction data and an
// `Account` object. It provides methods to retrieve the prepared transaction data,
// sign the transaction and sign+submit/send the transaction.
type PreparedTransaction map[string]interface{}

// Helper struct for offline signing



func NewRegularTransactionEssence(publicKeyHex string, transactionEssenceHex string) RegularTransactionEssence {
	return RegularTransactionEssence{
		Type: 1,
		PublicKey:                      publicKeyHex,
		TransactionEssence:             transactionEssenceHex,
	}
}


type PromoteMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PromoteMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PromoteMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}

type PromoteUncheckedMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data PromoteUncheckedMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type PromoteUncheckedMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}

// Protocol Parameters Milestone Option.
type ProtocolParamsMilestoneOption struct {
	// The protocol parameters in binary form. Hex-encoded with 0x prefix.
	Params string `json:"params" yaml:"params" mapstructure:"params"`

	// The to be applied protocol version.
	ProtocolVersion float64 `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`

	// The milestone index at which these protocol parameters become active.
	TargetMilestoneIndex float64 `json:"targetMilestoneIndex" yaml:"targetMilestoneIndex" mapstructure:"targetMilestoneIndex"`
}

// Query parameter for filtering output requests
type QueryParameter interface{}

type Question struct {
	// AdditionalInfo corresponds to the JSON schema field "additionalInfo".
	AdditionalInfo string `json:"additionalInfo" yaml:"additionalInfo" mapstructure:"additionalInfo"`

	// Answers corresponds to the JSON schema field "answers".
	Answers []Answer `json:"answers" yaml:"answers" mapstructure:"answers"`

	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

type QuestionStatus struct {
	// Answers corresponds to the JSON schema field "answers".
	Answers []AnswerStatus `json:"answers" yaml:"answers" mapstructure:"answers"`
}

type ReattachMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ReattachMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type ReattachMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}

type ReattachUncheckedMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data ReattachUncheckedMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type ReattachUncheckedMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId BlockId `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}

// Receipt milestone option.
type ReceiptMilestoneOption struct {
	// Whether this Receipt is the final one for a given migrated at index.
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// The index data.
	Funds []MigratedFunds `json:"funds" yaml:"funds" mapstructure:"funds"`

	// The milestone index at which the funds were migrated in the legacy network.
	MigratedAt float64 `json:"migratedAt" yaml:"migratedAt" mapstructure:"migratedAt"`

	// The TreasuryTransaction used to fund the funds.
	Transaction ReceiptMilestoneOptionTransaction `json:"transaction" yaml:"transaction" mapstructure:"transaction"`
}

// The TreasuryTransaction used to fund the funds.
type ReceiptMilestoneOptionTransaction struct {
	// The input of this transaction.
	Input ReceiptMilestoneOptionTransactionInput `json:"input" yaml:"input" mapstructure:"input"`

	// The output of this transaction.
	Output ReceiptMilestoneOptionTransactionOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// The input of this transaction.
type ReceiptMilestoneOptionTransactionInput struct {
	// The milestone id of the input.
	MilestoneId HexEncodedString `json:"milestoneId" yaml:"milestoneId" mapstructure:"milestoneId"`
}

// The output of this transaction.
type ReceiptMilestoneOptionTransactionOutput map[string]interface{}

// Receipts response details.
type ReceiptsResponse struct {
	// The receipts.
	Receipts []MilestoneReceipt `json:"receipts" yaml:"receipts" mapstructure:"receipts"`
}



type RegisterParticipationEventsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data RegisterParticipationEventsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type RegisterParticipationEventsMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options ParticipationEventRegistrationOptions `json:"options" yaml:"options" mapstructure:"options"`
}





type RequestFundsFromFaucetMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data RequestFundsFromFaucetMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type RequestFundsFromFaucetMethodData struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// The required storage deposit per output type
type RequiredStorageDeposit struct {
	// Alias corresponds to the JSON schema field "alias".
	Alias string `json:"alias" yaml:"alias" mapstructure:"alias"`

	// Basic corresponds to the JSON schema field "basic".
	Basic string `json:"basic" yaml:"basic" mapstructure:"basic"`

	// Foundry corresponds to the JSON schema field "foundry".
	Foundry string `json:"foundry" yaml:"foundry" mapstructure:"foundry"`

	// Nft corresponds to the JSON schema field "nft".
	Nft string `json:"nft" yaml:"nft" mapstructure:"nft"`
}



type RetryMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data RetryMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type RetryMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId string `json:"blockId" yaml:"blockId" mapstructure:"blockId"`
}

type RetryTransactionUntilIncludedMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data RetryTransactionUntilIncludedMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type RetryTransactionUntilIncludedMethodData struct {
	// Interval corresponds to the JSON schema field "interval".
	Interval float64 `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`

	// MaxAttempts corresponds to the JSON schema field "maxAttempts".
	MaxAttempts float64 `json:"maxAttempts,omitempty" yaml:"maxAttempts,omitempty" mapstructure:"maxAttempts,omitempty"`

	// TransactionId corresponds to the JSON schema field "transactionId".
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}

type RetryUntilIncludedMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data RetryUntilIncludedMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type RetryUntilIncludedMethodData struct {
	// BlockId corresponds to the JSON schema field "blockId".
	BlockId string `json:"blockId" yaml:"blockId" mapstructure:"blockId"`

	// Interval corresponds to the JSON schema field "interval".
	Interval float64 `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`

	// MaxAttempts corresponds to the JSON schema field "maxAttempts".
	MaxAttempts float64 `json:"maxAttempts,omitempty" yaml:"maxAttempts,omitempty" mapstructure:"maxAttempts,omitempty"`
}

type ReturnStrategy string

const ReturnStrategyGift ReturnStrategy = "Gift"
const ReturnStrategyReturn ReturnStrategy = "Return"
// ReuseAddress variant of RemainderValueStrategy
type ReuseAddress struct {
	// Strategy corresponds to the JSON schema field "strategy".
	Strategy string `json:"strategy" yaml:"strategy" mapstructure:"strategy"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}

type Secp256K1EcdsaSignature struct {
	// The public key.
	PublicKey HexEncodedString `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// The signature.
	Signature HexEncodedString `json:"signature" yaml:"signature" mapstructure:"signature"`
}

type SecretManagerMethods interface{}

// Supported secret managers
type SecretManagerType interface{}

// Secret manager that uses a seed.
type SeedSecretManager struct {
	// HexSeed corresponds to the JSON schema field "hexSeed".
	HexSeed string `json:"hexSeed" yaml:"hexSeed" mapstructure:"hexSeed"`
}

// A Segment of the BIP32 path
type Segment struct {
	// Bs corresponds to the JSON schema field "bs".
	Bs SegmentBs `json:"bs" yaml:"bs" mapstructure:"bs"`

	// Hardened corresponds to the JSON schema field "hardened".
	Hardened bool `json:"hardened" yaml:"hardened" mapstructure:"hardened"`
}

type SegmentBs struct {
	// BYTESPERELEMENT corresponds to the JSON schema field "BYTES_PER_ELEMENT".
	BYTESPERELEMENT float64 `json:"BYTES_PER_ELEMENT" yaml:"BYTES_PER_ELEMENT" mapstructure:"BYTES_PER_ELEMENT"`

	// Buffer corresponds to the JSON schema field "buffer".
	Buffer SegmentBsBuffer `json:"buffer" yaml:"buffer" mapstructure:"buffer"`

	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`

	// ByteOffset corresponds to the JSON schema field "byteOffset".
	ByteOffset float64 `json:"byteOffset" yaml:"byteOffset" mapstructure:"byteOffset"`

	// Length corresponds to the JSON schema field "length".
	Length float64 `json:"length" yaml:"length" mapstructure:"length"`
}

type SegmentBsBuffer struct {
	// ByteLength corresponds to the JSON schema field "byteLength".
	ByteLength float64 `json:"byteLength" yaml:"byteLength" mapstructure:"byteLength"`
}

type SendAmountMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SendAmountMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SendAmountMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Params corresponds to the JSON schema field "params".
	Params []SendAmountParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Address with a base token amount
type SendAmountParams struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Expiration corresponds to the JSON schema field "expiration".
	Expiration float64 `json:"expiration,omitempty" yaml:"expiration,omitempty" mapstructure:"expiration,omitempty"`

	// ReturnAddress corresponds to the JSON schema field "returnAddress".
	ReturnAddress string `json:"returnAddress,omitempty" yaml:"returnAddress,omitempty" mapstructure:"returnAddress,omitempty"`
}

// Address with native tokens
type SendNativeTokensParams struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Expiration corresponds to the JSON schema field "expiration".
	Expiration float64 `json:"expiration,omitempty" yaml:"expiration,omitempty" mapstructure:"expiration,omitempty"`

	// ReturnAddress corresponds to the JSON schema field "returnAddress".
	ReturnAddress string `json:"returnAddress,omitempty" yaml:"returnAddress,omitempty" mapstructure:"returnAddress,omitempty"`
}

// Address with an NftId
type SendNftParams struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`
}

type SendOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SendOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SendOutputsMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *TransactionOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs []SendOutputsMethodDataOutputsElem `json:"outputs" yaml:"outputs" mapstructure:"outputs"`
}

type SendOutputsMethodDataOutputsElem map[string]interface{}

type SetAliasMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SetAliasMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SetAliasMethodData struct {
	// Alias corresponds to the JSON schema field "alias".
	Alias string `json:"alias" yaml:"alias" mapstructure:"alias"`
}








type SignAndSubmitTransactionMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SignAndSubmitTransactionMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SignAndSubmitTransactionMethodData struct {
	// PreparedTransactionData corresponds to the JSON schema field
	// "preparedTransactionData".
	PreparedTransactionData PreparedTransactionData `json:"preparedTransactionData" yaml:"preparedTransactionData" mapstructure:"preparedTransactionData"`
}




type SignTransactionEssenceMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SignTransactionEssenceMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SignTransactionEssenceMethodData struct {
	// PreparedTransactionData corresponds to the JSON schema field
	// "preparedTransactionData".
	PreparedTransactionData PreparedTransactionData `json:"preparedTransactionData" yaml:"preparedTransactionData" mapstructure:"preparedTransactionData"`
}







// The signed transaction with inputs data
type SignedTransactionEssence struct {
	// InputsData corresponds to the JSON schema field "inputsData".
	InputsData InputSigningData `json:"inputsData" yaml:"inputsData" mapstructure:"inputsData"`

	// Transaction payload.
	TransactionPayload SignedTransactionEssenceTransactionPayload `json:"transactionPayload" yaml:"transactionPayload" mapstructure:"transactionPayload"`
}

// Transaction payload.
type SignedTransactionEssenceTransactionPayload struct {
	// The index name.
	Essence SignedTransactionEssenceTransactionPayloadEssence `json:"essence" yaml:"essence" mapstructure:"essence"`

	// The unlocks.
	Unlocks []SignedTransactionEssenceTransactionPayloadUnlocksElem `json:"unlocks" yaml:"unlocks" mapstructure:"unlocks"`
}

// The index name.
type SignedTransactionEssenceTransactionPayloadEssence map[string]interface{}

type SignedTransactionEssenceTransactionPayloadUnlocksElem map[string]interface{}

type StakingEventPayload struct {
	// AdditionalInfo corresponds to the JSON schema field "additionalInfo".
	AdditionalInfo string `json:"additionalInfo" yaml:"additionalInfo" mapstructure:"additionalInfo"`

	// Denominator corresponds to the JSON schema field "denominator".
	Denominator string `json:"denominator" yaml:"denominator" mapstructure:"denominator"`

	// Numerator corresponds to the JSON schema field "numerator".
	Numerator string `json:"numerator" yaml:"numerator" mapstructure:"numerator"`

	// RequiredMinimumRewards corresponds to the JSON schema field
	// "requiredMinimumRewards".
	RequiredMinimumRewards string `json:"requiredMinimumRewards" yaml:"requiredMinimumRewards" mapstructure:"requiredMinimumRewards"`

	// Symbol corresponds to the JSON schema field "symbol".
	Symbol string `json:"symbol" yaml:"symbol" mapstructure:"symbol"`

	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Type corresponds to the JSON schema field "type".
	Type float64 `json:"type" yaml:"type" mapstructure:"type"`
}




// Storage deposit strategy to be used for the output
type StorageDeposit struct {
	// ReturnStrategy corresponds to the JSON schema field "returnStrategy".
	ReturnStrategy *ReturnStrategy `json:"returnStrategy,omitempty" yaml:"returnStrategy,omitempty" mapstructure:"returnStrategy,omitempty"`

	// UseExcessIfLow corresponds to the JSON schema field "useExcessIfLow".
	UseExcessIfLow bool `json:"useExcessIfLow,omitempty" yaml:"useExcessIfLow,omitempty" mapstructure:"useExcessIfLow,omitempty"`
}



type SubmitAndStoreTransactionMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SubmitAndStoreTransactionMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SubmitAndStoreTransactionMethodData struct {
	// SignedTransactionData corresponds to the JSON schema field
	// "signedTransactionData".
	SignedTransactionData SignedTransactionEssence `json:"signedTransactionData" yaml:"signedTransactionData" mapstructure:"signedTransactionData"`
}

type SyncAccountMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data SyncAccountMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SyncAccountMethodData struct {
	// Options corresponds to the JSON schema field "options".
	Options *SyncOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}



type TrackedParticipationOverview struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Answers corresponds to the JSON schema field "answers".
	Answers []float64 `json:"answers" yaml:"answers" mapstructure:"answers"`

	// BlockId corresponds to the JSON schema field "blockId".
	BlockId string `json:"blockId" yaml:"blockId" mapstructure:"blockId"`

	// EndMilestoneIndex corresponds to the JSON schema field "endMilestoneIndex".
	EndMilestoneIndex float64 `json:"endMilestoneIndex" yaml:"endMilestoneIndex" mapstructure:"endMilestoneIndex"`

	// StartMilestoneIndex corresponds to the JSON schema field "startMilestoneIndex".
	StartMilestoneIndex float64 `json:"startMilestoneIndex" yaml:"startMilestoneIndex" mapstructure:"startMilestoneIndex"`
}

// A Transaction with metadata
type Transaction struct {
	// The block id in which the transaction payload was included
	BlockId string `json:"blockId,omitempty" yaml:"blockId,omitempty" mapstructure:"blockId,omitempty"`

	// The inclusion state of the transaction
	InclusionState InclusionState `json:"inclusionState" yaml:"inclusionState" mapstructure:"inclusionState"`

	// If the transaction was created by the wallet or someone else
	Incoming bool `json:"incoming" yaml:"incoming" mapstructure:"incoming"`

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []OutputResponse `json:"inputs" yaml:"inputs" mapstructure:"inputs"`

	// The network id in which the transaction was sent
	NetworkId string `json:"networkId" yaml:"networkId" mapstructure:"networkId"`

	// Note that can be set when sending a transaction and is only stored locally
	Note string `json:"note,omitempty" yaml:"note,omitempty" mapstructure:"note,omitempty"`

	// The transaction payload
	Payload TransactionPayload `json:"payload" yaml:"payload" mapstructure:"payload"`

	// The creation time
	Timestamp string `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// The transaction id
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}

type TransactionId string

type TransactionIdMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data TransactionIdMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type TransactionIdMethodData struct {
	// Transaction payload.
	Payload TransactionIdMethodDataPayload `json:"payload" yaml:"payload" mapstructure:"payload"`
}

// Transaction payload.
type TransactionIdMethodDataPayload struct {
	// The index name.
	Essence TransactionIdMethodDataPayloadEssence `json:"essence" yaml:"essence" mapstructure:"essence"`

	// The unlocks.
	Unlocks []TransactionIdMethodDataPayloadUnlocksElem `json:"unlocks" yaml:"unlocks" mapstructure:"unlocks"`
}

// The index name.
type TransactionIdMethodDataPayloadEssence map[string]interface{}

type TransactionIdMethodDataPayloadUnlocksElem map[string]interface{}

// Options for the transaction creation
type TransactionOptions struct {
	// AllowMicroAmount corresponds to the JSON schema field "allowMicroAmount".
	AllowMicroAmount bool `json:"allowMicroAmount" yaml:"allowMicroAmount" mapstructure:"allowMicroAmount"`

	// Burn corresponds to the JSON schema field "burn".
	Burn *Burn `json:"burn,omitempty" yaml:"burn,omitempty" mapstructure:"burn,omitempty"`

	// Custom inputs that should be used for the transaction
	CustomInputs []string `json:"customInputs,omitempty" yaml:"customInputs,omitempty" mapstructure:"customInputs,omitempty"`

	// MandatoryInputs corresponds to the JSON schema field "mandatoryInputs".
	MandatoryInputs []string `json:"mandatoryInputs,omitempty" yaml:"mandatoryInputs,omitempty" mapstructure:"mandatoryInputs,omitempty"`

	// Optional note, that is only stored locally
	Note string `json:"note,omitempty" yaml:"note,omitempty" mapstructure:"note,omitempty"`

	// RemainderValueStrategy corresponds to the JSON schema field
	// "remainderValueStrategy".
	RemainderValueStrategy TransactionOptionsRemainderValueStrategy `json:"remainderValueStrategy,omitempty" yaml:"remainderValueStrategy,omitempty" mapstructure:"remainderValueStrategy,omitempty"`

	// Tagged data payload.
	TaggedDataPayload *TransactionOptionsTaggedDataPayload `json:"taggedDataPayload,omitempty" yaml:"taggedDataPayload,omitempty" mapstructure:"taggedDataPayload,omitempty"`
}

type TransactionOptionsRemainderValueStrategy interface{}

// Tagged data payload.
type TransactionOptionsTaggedDataPayload struct {
	// The index data.
	Data HexEncodedString `json:"data" yaml:"data" mapstructure:"data"`

	// The tag to use to categorize the data.
	Tag HexEncodedString `json:"tag" yaml:"tag" mapstructure:"tag"`
}

// The transaction payload
type TransactionPayload struct {
	// The index name.
	Essence TransactionPayloadEssence `json:"essence" yaml:"essence" mapstructure:"essence"`

	// The unlocks.
	Unlocks []TransactionPayloadUnlocksElem `json:"unlocks" yaml:"unlocks" mapstructure:"unlocks"`
}

// The index name.
type TransactionPayloadEssence map[string]interface{}

type TransactionPayloadUnlocksElem map[string]interface{}

type TransactionsMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type UnhealthyNodesMethod struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Time unlocks to include in the output
type Unlocks struct {
	// ExpirationUnixTime corresponds to the JSON schema field "expirationUnixTime".
	ExpirationUnixTime float64 `json:"expirationUnixTime,omitempty" yaml:"expirationUnixTime,omitempty" mapstructure:"expirationUnixTime,omitempty"`

	// TimelockUnixTime corresponds to the JSON schema field "timelockUnixTime".
	TimelockUnixTime float64 `json:"timelockUnixTime,omitempty" yaml:"timelockUnixTime,omitempty" mapstructure:"timelockUnixTime,omitempty"`
}

type UnspentOutputsMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data UnspentOutputsMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type UnspentOutputsMethodData struct {
	// FilterOptions corresponds to the JSON schema field "filterOptions".
	FilterOptions *FilterOptions `json:"filterOptions,omitempty" yaml:"filterOptions,omitempty" mapstructure:"filterOptions,omitempty"`
}




type UtilsMethods interface{}

type VerifyEd25519SignatureMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data VerifyEd25519SignatureMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}


type VerifyEd25519SignatureMethodData struct {
	// Message corresponds to the JSON schema field "message".
	Message HexEncodedString `json:"message" yaml:"message" mapstructure:"message"`

	// Ed25519Signature signature.
	Signature VerifyEd25519SignatureMethodDataSignature `json:"signature" yaml:"signature" mapstructure:"signature"`
}

// Ed25519Signature signature.
type VerifyEd25519SignatureMethodDataSignature struct {
	// The public key.
	PublicKey HexEncodedString `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// The signature.
	Signature HexEncodedString `json:"signature" yaml:"signature" mapstructure:"signature"`
}

type VerifyMnemonicMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data VerifyMnemonicMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type VerifyMnemonicMethodData struct {
	// Mnemonic corresponds to the JSON schema field "mnemonic".
	Mnemonic string `json:"mnemonic" yaml:"mnemonic" mapstructure:"mnemonic"`
}

type VerifySecp256K1EcdsaSignatureMethod struct {
	// Data corresponds to the JSON schema field "data".
	Data VerifySecp256K1EcdsaSignatureMethodData `json:"data" yaml:"data" mapstructure:"data"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type VerifySecp256K1EcdsaSignatureMethodData struct {
	// Message corresponds to the JSON schema field "message".
	Message HexEncodedString `json:"message" yaml:"message" mapstructure:"message"`

	// PublicKey corresponds to the JSON schema field "publicKey".
	PublicKey HexEncodedString `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// Signature corresponds to the JSON schema field "signature".
	Signature HexEncodedString `json:"signature" yaml:"signature" mapstructure:"signature"`
}

type VotingEventPayload struct {
	// Questions corresponds to the JSON schema field "questions".
	Questions []Question `json:"questions" yaml:"questions" mapstructure:"questions"`

	// Type corresponds to the JSON schema field "type".
	Type float64 `json:"type" yaml:"type" mapstructure:"type"`
}



var enumValues_CoinType  = []interface {}{
  4218.0,
  4219.0,
  60.0,
}
var enumValues_ConflictReason  = []interface {}{
  0.0,
  1.0,
  2.0,
  3.0,
  4.0,
  5.0,
  6.0,
  7.0,
  8.0,
  9.0,
  10.0,
  11.0,
  12.0,
  255.0,
}
var enumValues_EventStatus  = []interface {}{
  "upcoming",
  "commencing",
  "holding",
  "ended",
}
var enumValues_ILoggerConfigLevelFilter  = []interface {}{
  "off",
  "error",
  "warn",
  "info",
  "debug",
  "trace",
}
var enumValues_InclusionState  = []interface {}{
  "Pending",
  "Confirmed",
  "Conflicting",
  "UnknownPruned",
}
var enumValues_LedgerDeviceType  = []interface {}{
  "LedgerNanoS",
  "LedgerNanoX",
  "LedgerNanoSPlus",
}
var enumValues_LedgerInclusionState  = []interface {}{
  "noTransaction",
  "included",
  "conflicting",
}
var enumValues_Network  = []interface {}{
  0.0,
  1.0,
}
var enumValues_OutputsToClaim  = []interface {}{
  "MicroTransactions",
  "NativeTokens",
  "Nfts",
  "Amount",
  "All",
}
var enumValues_ParticipationEventType  = []interface {}{
  0.0,
  1.0,
}
var enumValues_ReturnStrategy  = []interface {}{
  "Return",
  "Gift",
}